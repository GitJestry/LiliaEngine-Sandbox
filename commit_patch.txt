commit 1b5f48a9fd856fc9a12b95564dcfcac5ddb0827e
Author:     GitJestry <161480523+GitJestry@users.noreply.github.com>
AuthorDate: Mon Jan 26 00:21:42 2026 +0100
Commit:     GitJestry <161480523+GitJestry@users.noreply.github.com>
CommitDate: Mon Jan 26 00:21:42 2026 +0100

    fixed controller and view bad design choices

diff --git a/include/lilia/app/app.hpp b/include/lilia/app/app.hpp
index 265b5e0..9ac9137 100755
--- a/include/lilia/app/app.hpp
+++ b/include/lilia/app/app.hpp
@@ -1,10 +1,5 @@
 #pragma once
 
-#include <string>
-
-#include "lilia/chess_types.hpp"
-#include "lilia/constants.hpp"
-
 namespace lilia::app
 {
 
@@ -12,6 +7,9 @@ namespace lilia::app
   {
   public:
     App() = default;
+
+    /// @brief Main run point for the sandbox app
+    /// @return
     int run();
   };
 
diff --git a/include/lilia/app/game_session.hpp b/include/lilia/app/game_session.hpp
index 3e6be96..a6cf371 100644
--- a/include/lilia/app/game_session.hpp
+++ b/include/lilia/app/game_session.hpp
@@ -6,7 +6,10 @@
 
 namespace lilia::app
 {
-  // Runs exactly one session (a game or replay) and returns the next action.
+  /// @brief Runs exactly one session (a game or replay)
+  /// @param window
+  /// @param cfg
+  /// @return returns the next controller Action
   lilia::controller::NextAction runSession(sf::RenderWindow &window,
                                            const lilia::config::StartConfig &cfg);
 } // namespace lilia::app
diff --git a/include/lilia/chess_types.hpp b/include/lilia/chess_types.hpp
index 28071be..ac6e0e8 100755
--- a/include/lilia/chess_types.hpp
+++ b/include/lilia/chess_types.hpp
@@ -1,16 +1,39 @@
 #pragma once
 #include <cstdint>
-namespace lilia::core {
-using Square = std::uint8_t;
-constexpr Square NO_SQUARE = 64;
-enum class PieceType : std::uint8_t { Pawn = 0, Knight, Bishop, Rook, Queen, King, None };
+namespace lilia::core
+{
+  using Square = std::uint8_t;
+  constexpr Square NO_SQUARE = 64;
 
-constexpr int idx(PieceType p) noexcept {
-  return static_cast<int>(p);
-}
+  inline bool validSquare(core::Square sq)
+  {
+    return sq != core::NO_SQUARE;
+  }
 
-enum class Color : std::uint8_t { White = 0, Black = 1 };
-constexpr inline core::Color operator~(core::Color c) {
-  return c == core::Color::White ? core::Color::Black : core::Color::White;
-}
-}  // namespace lilia::core
+  constexpr std::uint8_t NUM_PIECE_TYPES = 6;
+  enum class PieceType : std::uint8_t
+  {
+    Pawn = 0,
+    Knight,
+    Bishop,
+    Rook,
+    Queen,
+    King,
+    None
+  };
+
+  constexpr int idx(PieceType p) noexcept
+  {
+    return static_cast<int>(p);
+  }
+
+  enum class Color : std::uint8_t
+  {
+    White = 0,
+    Black = 1
+  };
+  constexpr inline core::Color operator~(core::Color c)
+  {
+    return c == core::Color::White ? core::Color::Black : core::Color::White;
+  }
+} // namespace lilia::core
diff --git a/include/lilia/controller/game_controller.hpp b/include/lilia/controller/game_controller.hpp
index 51a9c5c..23819b3 100755
--- a/include/lilia/controller/game_controller.hpp
+++ b/include/lilia/controller/game_controller.hpp
@@ -9,9 +9,8 @@ namespace sf
   class Event;
 }
 
-#include "../chess_types.hpp"
-#include "../constants.hpp"
-#include "../view/audio/sound_manager.hpp"
+#include "lilia/constants.hpp"
+#include "lilia/view/audio/sound_manager.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
 #include "game_controller_types.hpp"
 #include "input_manager.hpp"
@@ -19,7 +18,6 @@ namespace sf
 #include "lilia/model/analysis/game_record.hpp"
 
 #include "lilia/model/analysis/config/start_config.hpp"
-#include "lilia/engine/uci/engine_registry.hpp"
 
 namespace lilia::model
 {
@@ -75,7 +73,6 @@ namespace lilia::controller
     bool m_black_is_bot{false};
     bool m_replay_mode{false};
 
-    std::atomic<int> m_eval_cp{0};
     NextAction m_next_action{NextAction::None};
 
     std::unique_ptr<LegalMoveCache> m_legal;
diff --git a/include/lilia/controller/game_controller_types.hpp b/include/lilia/controller/game_controller_types.hpp
index 0296f17..2715c09 100755
--- a/include/lilia/controller/game_controller_types.hpp
+++ b/include/lilia/controller/game_controller_types.hpp
@@ -6,7 +6,7 @@
 
 #include "lilia/model/analysis/analysis_types.hpp"
 #include "lilia/model/move.hpp"
-#include "../view/audio/sound_manager.hpp"
+#include "lilia/view/audio/sound_effect.hpp"
 
 namespace lilia::controller
 {
@@ -17,7 +17,6 @@ namespace lilia::controller
     core::Color moverColor;
     core::PieceType capturedType;
     view::sound::Effect sound;
-    int evalCp{};
   };
 
   struct Premove
diff --git a/include/lilia/controller/game_manager.hpp b/include/lilia/controller/game_manager.hpp
index 8d99b94..25964af 100755
--- a/include/lilia/controller/game_manager.hpp
+++ b/include/lilia/controller/game_manager.hpp
@@ -6,9 +6,9 @@
 #include <memory>
 #include <mutex>
 
-#include "../chess_types.hpp"
-#include "../constants.hpp"
-#include "../model/move.hpp"
+#include "lilia/chess_types.hpp"
+#include "lilia/constants.hpp"
+#include "lilia/model/move.hpp"
 #include "lilia/model/analysis/config/start_config.hpp"
 
 namespace lilia::model
diff --git a/include/lilia/controller/input_manager.hpp b/include/lilia/controller/input_manager.hpp
index f17384c..0e42a5e 100755
--- a/include/lilia/controller/input_manager.hpp
+++ b/include/lilia/controller/input_manager.hpp
@@ -9,7 +9,7 @@ namespace sf
 #include <functional>
 #include <optional>
 
-#include "../controller/mousepos.hpp"
+#include "lilia/controller/mousepos.hpp"
 
 namespace lilia::controller
 {
diff --git a/include/lilia/controller/player.hpp b/include/lilia/controller/player.hpp
old mode 100755
new mode 100644
diff --git a/include/lilia/controller/subsystems/attack_system.hpp b/include/lilia/controller/subsystems/attack_system.hpp
index 84b8030..600065b 100755
--- a/include/lilia/controller/subsystems/attack_system.hpp
+++ b/include/lilia/controller/subsystems/attack_system.hpp
@@ -2,37 +2,44 @@
 
 #include <vector>
 
-#include "../../chess_types.hpp"
-#include "../../model/move.hpp"
-#include "../../model/move_generator.hpp"
+#include "lilia/model/move.hpp"
+#include "lilia/model/move_generator.hpp"
 
-namespace lilia::model {
-class ChessGame;
-class Position;
-}  // namespace lilia::model
+namespace lilia::model
+{
+  class ChessGame;
+} // namespace lilia::model
 
-namespace lilia::view {
-class GameView;
+namespace lilia::view
+{
+  class GameView;
 }
 
-namespace lilia::controller {
+namespace lilia::controller
+{
 
-class LegalMoveCache;
+  class LegalMoveCache;
 
-class AttackSystem {
- public:
-  AttackSystem(view::GameView& view, model::ChessGame& game, LegalMoveCache& legal);
+  /// An attack system only for the board input system, to find possible pseudo attack squares of a piece
+  class AttackSystem
+  {
+  public:
+    AttackSystem(view::GameView &view, model::ChessGame &game, LegalMoveCache &legal);
 
-  const std::vector<core::Square>& attacks(core::Square pieceSq) const;
+    /// @brief it looks up wether pieceSq is a piece and finds its relative pseudo attacks.
+    /// because premoving is possible, the current visual state of the board is
+    /// @param pieceSq
+    /// @return the possible pseudo attack squares of the Piece
+    const std::vector<core::Square> &attacks(core::Square pieceSq) const;
 
- private:
-  view::GameView& m_view;
-  model::ChessGame& m_game;
-  LegalMoveCache& m_legal;
+  private:
+    view::GameView &m_view;
+    model::ChessGame &m_game;
+    LegalMoveCache &m_legal;
 
-  mutable model::MoveGenerator m_movegen;
-  mutable std::vector<model::Move> m_pseudo;
-  mutable std::vector<core::Square> m_out;
-};
+    mutable model::MoveGenerator m_movegen;
+    mutable std::vector<model::Move> m_pseudo;
+    mutable std::vector<core::Square> m_out;
+  };
 
-}  // namespace lilia::controller
+} // namespace lilia::controller
diff --git a/include/lilia/controller/subsystems/board_input_system.hpp b/include/lilia/controller/subsystems/board_input_system.hpp
index 56f58bf..1310393 100755
--- a/include/lilia/controller/subsystems/board_input_system.hpp
+++ b/include/lilia/controller/subsystems/board_input_system.hpp
@@ -4,11 +4,11 @@
 #include <chrono>
 #include <optional>
 
-#include "../../chess_types.hpp"
-#include "../../view/audio/sound_manager.hpp"
+#include "lilia/view/audio/sound_manager.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../input_manager.hpp"
-#include "../selection_manager.hpp"
+#include "lilia/controller/input_manager.hpp"
+#include "lilia/controller/selection_manager.hpp"
+#include "lilia/controller/subsystems/attack_system.hpp"
 
 namespace lilia::model
 {
@@ -20,20 +20,24 @@ namespace lilia::controller
 
   class GameManager;
   class LegalMoveCache;
-  class AttackSystem;
   class PremoveSystem;
 
   class BoardInputSystem
   {
   public:
     BoardInputSystem(view::GameView &view, model::ChessGame &game, InputManager &input,
-                     SelectionManager &sel, view::sound::SoundManager &sfx, AttackSystem &attacks,
-                     PremoveSystem &premove, LegalMoveCache &legal);
+                     SelectionManager &sel, view::sound::SoundManager &sfx,
+                     PremoveSystem &premove, AttackSystem &att);
 
+    /// @brief Sets the gamemanager pointer internally
+    /// @param gm
     void setGameManager(GameManager *gm) { m_game_manager = gm; }
 
+    /// @brief sets up the input callbacks from the current onClick, onDrag and onDrop
     void bindInputCallbacks();
 
+    /// @brief
+    /// @param pos
     void onMouseMove(core::MousePos pos);
     void onMousePressed(core::MousePos pos);
     void onMouseReleased(core::MousePos pos);
@@ -62,7 +66,6 @@ namespace lilia::controller
     view::sound::SoundManager &m_sfx;
     AttackSystem &m_attacks;
     PremoveSystem &m_premove;
-    LegalMoveCache &m_legal;
 
     GameManager *m_game_manager{nullptr};
 
diff --git a/include/lilia/controller/subsystems/clock_system.hpp b/include/lilia/controller/subsystems/clock_system.hpp
index e70f76a..de2bccf 100755
--- a/include/lilia/controller/subsystems/clock_system.hpp
+++ b/include/lilia/controller/subsystems/clock_system.hpp
@@ -3,15 +3,9 @@
 #include <memory>
 #include <optional>
 
-#include "../../chess_types.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../game_controller_types.hpp"
-#include "../time_controller.hpp"
-
-namespace lilia::model
-{
-  class ChessGame;
-}
+#include "lilia/controller/game_controller_types.hpp"
+#include "lilia/controller/time_controller.hpp"
 
 namespace lilia::controller
 {
@@ -19,7 +13,7 @@ namespace lilia::controller
   class ClockSystem
   {
   public:
-    ClockSystem(view::GameView &view, model::ChessGame &game);
+    ClockSystem(view::GameView &view);
 
     void reset(bool enabled, int baseSeconds, int incrementSeconds);
     void start(core::Color sideToMove);
@@ -39,7 +33,6 @@ namespace lilia::controller
 
   private:
     view::GameView &m_view;
-    model::ChessGame &m_game;
     std::unique_ptr<TimeController> m_time;
   };
 
diff --git a/include/lilia/controller/subsystems/game_end_system.hpp b/include/lilia/controller/subsystems/game_end_system.hpp
index 6b89f01..616c76b 100755
--- a/include/lilia/controller/subsystems/game_end_system.hpp
+++ b/include/lilia/controller/subsystems/game_end_system.hpp
@@ -2,15 +2,9 @@
 
 #include <string>
 
-#include "../../chess_types.hpp"
-#include "../../view/audio/sound_manager.hpp"
+#include "lilia/view/audio/sound_manager.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../game_controller_types.hpp"
-
-namespace lilia::model
-{
-  class ChessGame;
-}
+#include "lilia/controller/game_controller_types.hpp"
 
 namespace lilia::controller
 {
@@ -21,14 +15,13 @@ namespace lilia::controller
   class GameEndSystem
   {
   public:
-    GameEndSystem(view::GameView &view, model::ChessGame &game, view::sound::SoundManager &sfx);
+    GameEndSystem(view::GameView &view, view::sound::SoundManager &sfx);
 
     void show(core::GameResult res, core::Color sideToMove, bool whiteIsBot, bool blackIsBot,
               ClockSystem &clock, PremoveSystem &premove);
 
   private:
     view::GameView &m_view;
-    model::ChessGame &m_game;
     view::sound::SoundManager &m_sfx;
   };
 
diff --git a/include/lilia/controller/subsystems/history_system.hpp b/include/lilia/controller/subsystems/history_system.hpp
index 00af273..ef955d0 100755
--- a/include/lilia/controller/subsystems/history_system.hpp
+++ b/include/lilia/controller/subsystems/history_system.hpp
@@ -5,11 +5,10 @@
 #include <string>
 #include <vector>
 
-#include "../../chess_types.hpp"
-#include "../../view/audio/sound_manager.hpp"
+#include "lilia/view/audio/sound_manager.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../game_controller_types.hpp"
-#include "../selection_manager.hpp"
+#include "lilia/controller/game_controller_types.hpp"
+#include "lilia/controller/selection_manager.hpp"
 #include "lilia/model/analysis/analysis_types.hpp"
 #include "lilia/model/analysis/game_record.hpp"
 
@@ -27,7 +26,7 @@ namespace lilia::controller
   {
   public:
     HistorySystem(view::GameView &view, model::ChessGame &game, SelectionManager &sel,
-                  view::sound::SoundManager &sfx, std::atomic<int> &evalCp);
+                  view::sound::SoundManager &sfx);
 
     // removed startEval
     void reset(const std::string &startFen, const model::analysis::TimeView &startTime);
@@ -47,7 +46,6 @@ namespace lilia::controller
     void stepBackward(PremoveSystem &premove);
     void stepForward(PremoveSystem &premove);
 
-    void updateEvalAtHead();
     void syncCapturedPieces();
 
     void stashSelectedPiece();
@@ -66,9 +64,6 @@ namespace lilia::controller
     SelectionManager &m_sel;
     view::sound::SoundManager &m_sfx;
 
-    // keep live eval
-    std::atomic<int> &m_eval_cp;
-
     std::vector<std::string> m_fen_history;
     std::vector<MoveView> m_move_history;
     std::vector<model::analysis::TimeView> m_time_history;
diff --git a/include/lilia/controller/subsystems/legal_move_cache.hpp b/include/lilia/controller/subsystems/legal_move_cache.hpp
index 5814421..f816ba8 100755
--- a/include/lilia/controller/subsystems/legal_move_cache.hpp
+++ b/include/lilia/controller/subsystems/legal_move_cache.hpp
@@ -2,28 +2,31 @@
 
 #include <vector>
 
-#include "../../chess_types.hpp"
-#include "../../model/move.hpp"
+#include "lilia/model/move.hpp"
 
-namespace lilia::model {
-class ChessGame;
+namespace lilia::model
+{
+  class ChessGame;
 }
 
-namespace lilia::controller {
+namespace lilia::controller
+{
 
-class LegalMoveCache {
- public:
-  explicit LegalMoveCache(model::ChessGame& game) : m_game(game) {}
+  /// Adapts on the game move generation and simplifies logic.
+  class LegalMoveCache
+  {
+  public:
+    explicit LegalMoveCache(model::ChessGame &game) : m_game(game) {}
 
-  void invalidate() { m_cached = nullptr; }
+    void invalidate() { m_cached = nullptr; }
 
-  const std::vector<model::Move>& legal() const;
-  bool contains(core::Square from, core::Square to) const;
-  bool isPromotion(core::Square from, core::Square to) const;
+    const std::vector<model::Move> &legal() const;
+    bool contains(core::Square from, core::Square to) const;
+    bool isPromotion(core::Square from, core::Square to) const;
 
- private:
-  model::ChessGame& m_game;
-  mutable const std::vector<model::Move>* m_cached{nullptr};
-};
+  private:
+    model::ChessGame &m_game;
+    mutable const std::vector<model::Move> *m_cached{nullptr};
+  };
 
-}  // namespace lilia::controller
+} // namespace lilia::controller
diff --git a/include/lilia/controller/subsystems/move_execution_system.hpp b/include/lilia/controller/subsystems/move_execution_system.hpp
index fc47ed0..79e2b97 100755
--- a/include/lilia/controller/subsystems/move_execution_system.hpp
+++ b/include/lilia/controller/subsystems/move_execution_system.hpp
@@ -2,10 +2,8 @@
 
 #include <atomic>
 
-#include "../../chess_types.hpp"
-#include "../../view/audio/sound_manager.hpp"
+#include "lilia/view/audio/sound_manager.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../game_controller_types.hpp"
 
 namespace lilia::model
 {
@@ -24,8 +22,7 @@ namespace lilia::controller
   class MoveExecutionSystem
   {
   public:
-    MoveExecutionSystem(view::GameView &view, model::ChessGame &game, view::sound::SoundManager &sfx,
-                        std::atomic<int> &evalCp, LegalMoveCache &legal, HistorySystem &history,
+    MoveExecutionSystem(view::GameView &view, model::ChessGame &game, view::sound::SoundManager &sfx, LegalMoveCache &legal, HistorySystem &history,
                         ClockSystem &clock, PremoveSystem &premove);
 
     void applyMove(const model::Move &move, bool isPlayerMove, bool onClick);
@@ -34,7 +31,6 @@ namespace lilia::controller
     view::GameView &m_view;
     model::ChessGame &m_game;
     view::sound::SoundManager &m_sfx;
-    std::atomic<int> &m_eval_cp;
 
     LegalMoveCache &m_legal;
     HistorySystem &m_history;
diff --git a/include/lilia/controller/subsystems/premove_system.hpp b/include/lilia/controller/subsystems/premove_system.hpp
index 8572913..36d4d28 100755
--- a/include/lilia/controller/subsystems/premove_system.hpp
+++ b/include/lilia/controller/subsystems/premove_system.hpp
@@ -6,14 +6,16 @@
 #include <deque>
 #include <vector>
 
-#include "../../chess_types.hpp"
-#include "../../model/chess_game.hpp"
-#include "../../model/move.hpp"
-#include "../../model/move_generator.hpp"
-#include "../../model/position.hpp"
-#include "../../view/audio/sound_manager.hpp"
+#include "lilia/view/audio/sound_manager.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../game_controller_types.hpp"
+#include "lilia/controller/game_controller_types.hpp"
+#include "lilia/model/position.hpp"
+#include "lilia/model/move_generator.hpp"
+
+namespace lilia::model
+{
+  class ChessGame;
+} // namespace lilia::model
 
 namespace lilia::controller
 {
diff --git a/include/lilia/controller/subsystems/ui_event_system.hpp b/include/lilia/controller/subsystems/ui_event_system.hpp
index 402aeb2..ce82523 100755
--- a/include/lilia/controller/subsystems/ui_event_system.hpp
+++ b/include/lilia/controller/subsystems/ui_event_system.hpp
@@ -3,7 +3,7 @@
 #include <SFML/Window/Event.hpp>
 
 #include "lilia/view/ui/screens/game_view.hpp"
-#include "../game_controller_types.hpp"
+#include "lilia/controller/game_controller_types.hpp"
 
 namespace lilia::model
 {
diff --git a/include/lilia/controller/uci_engine_player.hpp b/include/lilia/controller/uci_engine_player.hpp
index cab2950..61d90a7 100644
--- a/include/lilia/controller/uci_engine_player.hpp
+++ b/include/lilia/controller/uci_engine_player.hpp
@@ -4,7 +4,7 @@
 #include <memory>
 #include <string>
 
-#include "lilia/controller/player.hpp" // IPlayer
+#include "lilia/controller/player.hpp"
 #include "lilia/model/chess_game.hpp"
 #include "lilia/model/analysis/config/start_config.hpp"
 #include "lilia/engine/uci/uci_engine_process.hpp"
diff --git a/include/lilia/model/analysis/replay_info.hpp b/include/lilia/model/analysis/replay_info.hpp
index 24aee79..9ccecc1 100644
--- a/include/lilia/model/analysis/replay_info.hpp
+++ b/include/lilia/model/analysis/replay_info.hpp
@@ -4,11 +4,17 @@
 
 #include "lilia/model/analysis/game_record.hpp"
 #include "lilia/model/analysis/outcome.hpp"
-#include "lilia/player_info.hpp"
 
 namespace lilia::model::analysis
 {
 
+  struct PlayerInfo
+  {
+    std::string name;
+    std::string elo;
+    std::string icon_name;
+  };
+
   struct ReplayInfo
   {
     std::string event;
@@ -16,8 +22,8 @@ namespace lilia::model::analysis
     std::string date;
     std::string round;
 
-    PlayerInfo white;
-    PlayerInfo black;
+    PlayerInfo white_info;
+    PlayerInfo black_info;
 
     std::string result; // "1-0", "0-1", "1/2-1/2", "*"
     Outcome whiteOutcome = Outcome::Unknown;
diff --git a/include/lilia/model/chess_game.hpp b/include/lilia/model/chess_game.hpp
index 584ee35..fef14a4 100755
--- a/include/lilia/model/chess_game.hpp
+++ b/include/lilia/model/chess_game.hpp
@@ -9,40 +9,48 @@
 #include "position.hpp"
 #include "zobrist.hpp"
 
-namespace lilia::model {
-
-class ChessGame {
- public:
-  ChessGame();
-
-  void setPosition(const std::string& fen);
-  void buildHash();
-  bool doMove(core::Square from, core::Square to,
-              core::PieceType promotion = core::PieceType::None);
-  bool doMoveUCI(const std::string& uciMove);
-
-  bb::Piece getPiece(core::Square sq);
-  const GameState& getGameState();
-  const std::vector<Move>& generateLegalMoves();
-  std::optional<Move> getMove(core::Square from, core::Square to);
-
-  bool isKingInCheck(core::Color from) const;
-  core::Square getRookSquareFromCastleside(CastleSide castleSide, core::Color side);
-  core::Square getKingSquare(core::Color color);
-  core::GameResult getResult();
-  void setResult(core::GameResult res);
-  Position& getPositionRefForBot();
-
-  std::string getFen() const; 
-
-  void checkGameResult();
-
- private:
-  MoveGenerator m_move_gen;
-  Position m_position;
-  core::GameResult m_result;
-  std::vector<Move> m_pseudo_moves;
-  std::vector<Move> m_legal_moves;
-};
-
-}  // namespace lilia::model
+namespace lilia::model
+{
+
+  /**
+   * This is the definitive entry point for the controller to manage a game.
+   * Beside this for move gen the MoveGenerator class can, and only should be used.
+   * Any other class is not intended to be used by the controller and rather is for the engine itself.
+   */
+  class ChessGame
+  {
+  public:
+    ChessGame();
+
+    void setPosition(const std::string &fen);
+    void buildHash();
+    bool doMove(core::Square from, core::Square to,
+                core::PieceType promotion = core::PieceType::None);
+    bool doMoveUCI(const std::string &uciMove);
+
+    bb::Piece getPiece(core::Square sq);
+    const GameState &getGameState();
+    const std::vector<Move> &generateLegalMoves();
+    const std::vector<Move> &generatePseudoLegalMoves();
+    std::optional<Move> getMove(core::Square from, core::Square to);
+
+    bool isKingInCheck(core::Color from) const;
+    core::Square getRookSquareFromCastleside(CastleSide castleSide, core::Color side);
+    core::Square getKingSquare(core::Color color);
+    core::GameResult getResult();
+    void setResult(core::GameResult res);
+    Position &getPositionRefForBot();
+
+    std::string getFen() const;
+
+    void checkGameResult();
+
+  private:
+    MoveGenerator m_move_gen;
+    Position m_position;
+    core::GameResult m_result;
+    std::vector<Move> m_pseudo_moves;
+    std::vector<Move> m_legal_moves;
+  };
+
+} // namespace lilia::model
diff --git a/include/lilia/player_info.hpp b/include/lilia/player_info.hpp
deleted file mode 100755
index 766db87..0000000
--- a/include/lilia/player_info.hpp
+++ /dev/null
@@ -1,13 +0,0 @@
-#pragma once
-
-#include <string>
-
-namespace lilia {
-
-struct PlayerInfo {
-  std::string name;
-  std::string elo;
-  std::string iconPath;
-};
-
-}  // namespace lilia
diff --git a/include/lilia/view/audio/sound_effect.hpp b/include/lilia/view/audio/sound_effect.hpp
new file mode 100644
index 0000000..b356c57
--- /dev/null
+++ b/include/lilia/view/audio/sound_effect.hpp
@@ -0,0 +1,20 @@
+#pragma once
+
+namespace lilia::view::sound
+{
+
+  enum class Effect
+  {
+    PlayerMove,
+    EnemyMove,
+    Capture,
+    Check,
+    Warning,
+    Castle,
+    Promotion,
+    GameBegins,
+    GameEnds,
+    Premove
+  };
+
+}
diff --git a/include/lilia/view/audio/sound_manager.hpp b/include/lilia/view/audio/sound_manager.hpp
index 02ae0a5..972a860 100755
--- a/include/lilia/view/audio/sound_manager.hpp
+++ b/include/lilia/view/audio/sound_manager.hpp
@@ -4,44 +4,34 @@
 #include <memory>
 #include <string>
 #include <unordered_map>
+#include "sound_effect.hpp"
 
-namespace lilia::view::sound {
+namespace lilia::view::sound
+{
 
-enum class Effect {
-  PlayerMove,
-  EnemyMove,
-  Capture,
-  Check,
-  Warning,
-  Castle,
-  Promotion,
-  GameBegins,
-  GameEnds,
-  Premove
-};
+  class SoundManager
+  {
+  public:
+    SoundManager() = default;
+    ~SoundManager() = default;
 
-class SoundManager {
- public:
-  SoundManager() = default;
-  ~SoundManager() = default;
+    void loadSounds();
 
-  void loadSounds();
+    void playEffect(Effect effect);
 
-  void playEffect(Effect effect);
+    void playBackgroundMusic(const std::string &filename, bool loop = true);
+    void stopBackgroundMusic();
+    void setMusicVolume(float volume);
+    void setEffectsVolume(float volume);
 
-  void playBackgroundMusic(const std::string& filename, bool loop = true);
-  void stopBackgroundMusic();
-  void setMusicVolume(float volume);
-  void setEffectsVolume(float volume);
+  private:
+    void loadEffect(const std::string &name, const std::string &filepath);
 
- private:
-  void loadEffect(const std::string& name, const std::string& filepath);
+    std::unordered_map<std::string, sf::SoundBuffer> m_buffers;
+    std::unordered_map<std::string, sf::Sound> m_sounds;
 
-  std::unordered_map<std::string, sf::SoundBuffer> m_buffers;
-  std::unordered_map<std::string, sf::Sound> m_sounds;
+    sf::Music m_music;
+    float m_effects_volume = 100.f;
+  };
 
-  sf::Music m_music;
-  float m_effects_volume = 100.f;
-};
-
-}  // namespace lilia::view::sound
+} // namespace lilia::view::sound
diff --git a/include/lilia/view/ui/render/engine_icons.hpp b/include/lilia/view/ui/render/engine_icons.hpp
index 3cb947d..9e85924 100644
--- a/include/lilia/view/ui/render/engine_icons.hpp
+++ b/include/lilia/view/ui/render/engine_icons.hpp
@@ -4,9 +4,9 @@
 namespace lilia::view::ui::icons
 {
   // Paths are relative to your runtime assets directory copy (the "assets" folder next to the exe).
-  inline constexpr std::string_view LILIA = "assets/icons/lilia_transparent.png";
-  inline constexpr std::string_view STOCKFISH = "assets/icons/stockfish.png";
-  inline constexpr std::string_view EXTERNAL = "assets/icons/external.png";
+  inline constexpr std::string_view LILIA = "lilia_transparent.png";
+  inline constexpr std::string_view STOCKFISH = "stockfish.png";
+  inline constexpr std::string_view EXTERNAL = "external.png";
 
-  inline constexpr std::string_view DEFAULT_FALLBACK = "assets/icons/challenger.png";
+  inline constexpr std::string_view DEFAULT_FALLBACK = "challenger.png";
 }
diff --git a/include/lilia/view/ui/render/image_provider.hpp b/include/lilia/view/ui/render/image_provider.hpp
new file mode 100644
index 0000000..1b8925b
--- /dev/null
+++ b/include/lilia/view/ui/render/image_provider.hpp
@@ -0,0 +1,10 @@
+#pragma once
+
+namespace lilia::view::ui::render
+{
+
+  class ImageProvider
+  {
+  };
+
+};
diff --git a/include/lilia/view/ui/render/player_info.hpp b/include/lilia/view/ui/render/player_info.hpp
new file mode 100644
index 0000000..32bcb99
--- /dev/null
+++ b/include/lilia/view/ui/render/player_info.hpp
@@ -0,0 +1,13 @@
+#pragma once
+
+#include <string>
+
+namespace lilia::view::ui::render
+{
+
+  struct PlayerInfo
+  {
+    std::string name, elo, icon_name;
+  };
+
+};
diff --git a/include/lilia/view/ui/render/player_info_resolver.hpp b/include/lilia/view/ui/render/player_info_resolver.hpp
index f3209fc..0c4036e 100644
--- a/include/lilia/view/ui/render/player_info_resolver.hpp
+++ b/include/lilia/view/ui/render/player_info_resolver.hpp
@@ -2,13 +2,13 @@
 #include <string>
 
 #include "lilia/model/analysis/config/start_config.hpp"
-#include "lilia/player_info.hpp"
 #include "lilia/chess_types.hpp"
+#include "lilia/model/analysis/replay_info.hpp"
 
 namespace lilia::view
 {
   // Builds UI-facing player info from a side config (human or engine).
   // - Uses engine displayName/version from EngineRef.
   // - Selects icon by engineId policy.
-  PlayerInfo makePlayerInfo(const lilia::config::SideConfig &side, core::Color color);
+  model::analysis::PlayerInfo makePlayerInfo(const lilia::config::SideConfig &side, core::Color color);
 }
diff --git a/include/lilia/view/ui/render/render_constants.hpp b/include/lilia/view/ui/render/render_constants.hpp
index ba76563..eacdd69 100755
--- a/include/lilia/view/ui/render/render_constants.hpp
+++ b/include/lilia/view/ui/render/render_constants.hpp
@@ -79,23 +79,20 @@ namespace lilia::view::constant
   // ------------------ Asset Paths ------------------
   namespace path
   {
-    inline constexpr std::string_view HAND_OPEN{"assets/icons/cursor_hand_open.png"};
-    inline constexpr std::string_view HAND_CLOSED{"assets/icons/cursor_hand_closed.png"};
-    inline constexpr std::string_view FONT{"assets/font/OpenSans-Regular.ttf"};
-    inline constexpr std::string_view ICON_LILIA{"assets/icons/lilia.png"};
-    inline constexpr std::string_view ICON_LILIA_START{"assets/icons/lilia_transparent.png"};
-    inline constexpr std::string_view ICON_CHALLENGER{"assets/icons/challenger.png"};
-    inline constexpr std::string_view ICON_RESIGN{"assets/icons/resign.png"};
-    inline constexpr std::string_view ICON_PREV{"assets/icons/prev.png"};
-    inline constexpr std::string_view ICON_NEXT{"assets/icons/next.png"};
-    inline constexpr std::string_view ICON_SETTINGS{"assets/icons/settings.png"};
-    inline constexpr std::string_view ICON_NEW_BOT{"assets/icons/new_bot.png"};
-    inline constexpr std::string_view ICON_REMATCH{"assets/icons/rematch.png"};
-
+    inline constexpr std::string_view FONT_DIR{"assets/font/OpenSans-Regular.ttf"};
     inline constexpr std::string_view PIECES_DIR{"assets/textures"};
+    inline constexpr std::string_view ICONS_DIR{"assets/icons"};
     inline constexpr std::string_view SFX_DIR{"assets/audio/sfx"};
   } // namespace path
 
+  namespace asset_name
+  {
+    inline constexpr std::string_view ICON_LILIA_START = "lilia_transparent.png";
+    inline constexpr std::string_view HAND_OPEN = "cursor_hand_open.png";
+    inline constexpr std::string_view HAND_CLOSED = "cursor_hand_closed.png";
+    inline constexpr std::string_view ICON_CHALLENGER = "challenger.png";
+  }
+
   // ------------------ SFX Keys ------------------
   namespace sfx
   {
diff --git a/include/lilia/view/ui/render/texture_table.hpp b/include/lilia/view/ui/render/resource_table.hpp
similarity index 55%
rename from include/lilia/view/ui/render/texture_table.hpp
rename to include/lilia/view/ui/render/resource_table.hpp
index 929e643..c94e2e6 100755
--- a/include/lilia/view/ui/render/texture_table.hpp
+++ b/include/lilia/view/ui/render/resource_table.hpp
@@ -16,12 +16,14 @@ namespace sf
 namespace lilia::view
 {
 
-  class TextureTable
+  class ResourceTable
   {
   public:
-    static TextureTable &getInstance();
+    static ResourceTable &getInstance();
 
-    [[nodiscard]] const sf::Texture &get(const std::string &name);
+    [[nodiscard]] const sf::Texture &getTexture(const std::string &name);
+    [[nodiscard]] const sf::Texture &getAssetTexture(const std::string &name);
+    [[nodiscard]] const sf::Image &getImage(const std::string &name);
 
     // Optionaler Bootstrap; wird auch automatisch im ctor gemacht (siehe cpp).
     void preLoad();
@@ -30,14 +32,15 @@ namespace lilia::view
     void reloadForPalette();
     void load(std::string_view name, const sf::Color &color, sf::Vector2u size = {1, 1});
 
-    TextureTable();
-    ~TextureTable();
+    ResourceTable();
+    ~ResourceTable();
 
-    TextureTable(const TextureTable &) = delete;
-    TextureTable &operator=(const TextureTable &) = delete;
+    ResourceTable(const ResourceTable &) = delete;
+    ResourceTable &operator=(const ResourceTable &) = delete;
 
     std::uint64_t m_paletteListenerId{0};
     std::unordered_map<std::string, sf::Texture> m_textures;
+    std::unordered_map<std::string, sf::Image> m_images;
   };
 
 } // namespace lilia::view
diff --git a/include/lilia/view/ui/render/scene/piece_texture_util.hpp b/include/lilia/view/ui/render/scene/piece_texture_util.hpp
new file mode 100644
index 0000000..f9f7fc8
--- /dev/null
+++ b/include/lilia/view/ui/render/scene/piece_texture_util.hpp
@@ -0,0 +1,11 @@
+#pragma once
+
+#include "lilia/view/ui/render/resource_table.hpp"
+#include "lilia/chess_types.hpp"
+
+namespace lilia::view::ui::render::utils
+{
+
+  const sf::Texture &getPieceTexture(core::PieceType type, core::Color color);
+
+};
diff --git a/include/lilia/view/ui/screens/game_view.hpp b/include/lilia/view/ui/screens/game_view.hpp
index 9853e51..2d2875e 100755
--- a/include/lilia/view/ui/screens/game_view.hpp
+++ b/include/lilia/view/ui/screens/game_view.hpp
@@ -24,7 +24,6 @@
 #include "lilia/view/ui/views/player_info_view.hpp"
 #include "lilia/view/ui/render/scene/promotion_manager.hpp"
 #include "lilia/view/ui/style/theme_cache.hpp"
-#include "lilia/model/analysis/replay_info.hpp"
 
 namespace lilia::view
 {
@@ -172,7 +171,7 @@ namespace lilia::view
     void clearOutcomeBadges();
 
     // Generic: update player badges (useful for replay and future config refactor)
-    void setPlayers(const PlayerInfo &white, const PlayerInfo &black);
+    void setPlayersInfo(const model::analysis::PlayerInfo &white, const model::analysis::PlayerInfo &black);
 
   private:
     void layout(unsigned int width, unsigned int height);
diff --git a/include/lilia/view/ui/views/player_info_view.hpp b/include/lilia/view/ui/views/player_info_view.hpp
index f25af53..d50ce51 100755
--- a/include/lilia/view/ui/views/player_info_view.hpp
+++ b/include/lilia/view/ui/views/player_info_view.hpp
@@ -12,9 +12,9 @@
 
 #include "lilia/view/ui/render/entity.hpp"
 #include "lilia/chess_types.hpp"
-#include "lilia/player_info.hpp"
 #include "lilia/view/ui/style/theme.hpp"
 #include "lilia/model/analysis/outcome.hpp"
+#include "lilia/model/analysis/replay_info.hpp"
 
 namespace lilia::view
 {
@@ -26,7 +26,7 @@ namespace lilia::view
 
     void setTheme(const ui::Theme *t) noexcept { m_theme = t; }
 
-    void setInfo(const PlayerInfo &info);
+    void setInfo(const model::analysis::PlayerInfo &info);
     void setPlayerColor(core::Color color);
 
     void setOutcome(std::optional<model::analysis::Outcome> outcome);
@@ -73,6 +73,6 @@ namespace lilia::view
     std::vector<Entity> m_capturedPieces;
     std::vector<std::pair<core::PieceType, core::Color>> m_capturedInfo;
 
-    std::string m_iconPath;
+    std::string m_icon_name;
   };
 } // namespace lilia::view
diff --git a/src/lilia/app/app.cpp b/src/lilia/app/app.cpp
index f2b2e86..610dd93 100755
--- a/src/lilia/app/app.cpp
+++ b/src/lilia/app/app.cpp
@@ -2,8 +2,7 @@
 
 #include <SFML/Graphics/RenderWindow.hpp>
 
-#include "lilia/engine/engine.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 #include "lilia/view/ui/screens/start_screen.hpp"
 
 #include "lilia/app/game_session.hpp"
@@ -13,9 +12,7 @@ namespace lilia::app
 {
   int App::run()
   {
-    // Engine init must handle registry/bootstrap internally (NOT App).
-    engine::Engine::init();
-    lilia::view::TextureTable::getInstance().preLoad();
+    lilia::view::ResourceTable::getInstance().preLoad();
 
     sf::RenderWindow window(
         sf::VideoMode(lilia::view::constant::WINDOW_TOTAL_WIDTH,
@@ -27,7 +24,6 @@ namespace lilia::app
       lilia::view::StartScreen startScreen(window);
       const auto cfg = startScreen.run();
 
-      // Rematch loop uses the same config (as expected).
       for (;;)
       {
         const auto action = lilia::app::runSession(window, cfg);
diff --git a/src/lilia/controller/game_controller.cpp b/src/lilia/controller/game_controller.cpp
index 9d9e9d4..e7a046c 100755
--- a/src/lilia/controller/game_controller.cpp
+++ b/src/lilia/controller/game_controller.cpp
@@ -4,7 +4,6 @@
 #include <SFML/Window/Mouse.hpp>
 
 #include "lilia/controller/game_manager.hpp"
-#include "lilia/controller/subsystems/attack_system.hpp"
 #include "lilia/controller/subsystems/board_input_system.hpp"
 #include "lilia/controller/subsystems/clock_system.hpp"
 #include "lilia/controller/subsystems/game_end_system.hpp"
@@ -16,9 +15,8 @@
 #include "lilia/model/analysis/game_record.hpp"
 #include "lilia/model/chess_game.hpp"
 #include "lilia/model/analysis/replay_info.hpp"
-#include "lilia/model/analysis/replay_info.hpp"
-#include "lilia/constants.hpp"
 #include "lilia/view/ui/render/player_info_resolver.hpp"
+#include "lilia/controller/subsystems/attack_system.hpp"
 
 namespace lilia::controller
 {
@@ -39,15 +37,14 @@ namespace lilia::controller
     m_game_manager = std::make_unique<GameManager>(game);
 
     m_legal = std::make_unique<LegalMoveCache>(m_game);
-    m_attacks = std::make_unique<AttackSystem>(m_view, m_game, *m_legal);
     m_premove = std::make_unique<PremoveSystem>(m_view, m_game, m_sfx, *m_legal);
-    m_history = std::make_unique<HistorySystem>(m_view, m_game, m_selection, m_sfx, m_eval_cp);
-    m_clock = std::make_unique<ClockSystem>(m_view, m_game);
-    m_move_exec = std::make_unique<MoveExecutionSystem>(m_view, m_game, m_sfx, m_eval_cp, *m_legal,
+    m_history = std::make_unique<HistorySystem>(m_view, m_game, m_selection, m_sfx);
+    m_clock = std::make_unique<ClockSystem>(m_view);
+    m_move_exec = std::make_unique<MoveExecutionSystem>(m_view, m_game, m_sfx, *m_legal,
                                                         *m_history, *m_clock, *m_premove);
-    m_game_end = std::make_unique<GameEndSystem>(m_view, m_game, m_sfx);
-    m_board_input = std::make_unique<BoardInputSystem>(m_view, m_game, m_input, m_selection, m_sfx,
-                                                       *m_attacks, *m_premove, *m_legal);
+    m_attacks = std::make_unique<AttackSystem>(m_view, m_game, *m_legal);
+    m_game_end = std::make_unique<GameEndSystem>(m_view, m_sfx);
+    m_board_input = std::make_unique<BoardInputSystem>(m_view, m_game, m_input, m_selection, m_sfx, *m_premove, *m_attacks);
     m_ui = std::make_unique<UiEventSystem>(m_view, m_game, *m_history, *m_premove, m_next_action);
 
     m_premove->setGameManager(m_game_manager.get());
@@ -104,8 +101,8 @@ namespace lilia::controller
     m_view.setBotMode(whiteIsBot || blackIsBot);
     m_white_is_bot = whiteIsBot;
     m_black_is_bot = blackIsBot;
-    m_view.setPlayers(lilia::view::makePlayerInfo(cfg.white, core::Color::White),
-                      lilia::view::makePlayerInfo(cfg.black, core::Color::Black));
+    m_view.setPlayersInfo(lilia::view::makePlayerInfo(cfg.white, core::Color::White),
+                          lilia::view::makePlayerInfo(cfg.black, core::Color::Black));
 
     // New: hand full StartConfig to GameManager (which creates UCI players)
     m_game_manager->startGame(cfg);
@@ -136,7 +133,6 @@ namespace lilia::controller
   void GameController::update(float dt)
   {
     m_view.update(dt);
-    m_history->updateEvalAtHead();
 
     if (m_replay_mode)
       return;
@@ -226,8 +222,8 @@ namespace lilia::controller
     hdr.date = ri.date;
     hdr.round = ri.round;
 
-    hdr.white = ri.white;
-    hdr.black = ri.black;
+    hdr.white_info = ri.white_info;
+    hdr.black_info = ri.black_info;
 
     hdr.result = ri.result;
     hdr.whiteOutcome = ri.whiteOutcome;
@@ -237,10 +233,10 @@ namespace lilia::controller
     hdr.openingName = ri.openingName;
 
     // Ensure icon paths are valid to avoid TextureTable lookups on empty strings.
-    if (hdr.white.iconPath.empty())
-      hdr.white.iconPath = std::string{lilia::view::constant::path::ICON_CHALLENGER};
-    if (hdr.black.iconPath.empty())
-      hdr.black.iconPath = std::string{lilia::view::constant::path::ICON_CHALLENGER};
+    if (hdr.white_info.icon_name.empty())
+      hdr.white_info.icon_name = std::string{lilia::view::constant::asset_name::ICON_CHALLENGER};
+    if (hdr.black_info.icon_name.empty())
+      hdr.black_info.icon_name = std::string{lilia::view::constant::asset_name::ICON_CHALLENGER};
 
     m_view.setReplayHeader(std::move(hdr));
 
diff --git a/src/lilia/controller/subsystems/attack_system.cpp b/src/lilia/controller/subsystems/attack_system.cpp
index d2de05a..2e12055 100755
--- a/src/lilia/controller/subsystems/attack_system.cpp
+++ b/src/lilia/controller/subsystems/attack_system.cpp
@@ -1,21 +1,12 @@
 #include "lilia/controller/subsystems/attack_system.hpp"
 
 #include "lilia/model/chess_game.hpp"
-#include "lilia/model/position.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
 #include "lilia/controller/subsystems/legal_move_cache.hpp"
 
 namespace lilia::controller
 {
 
-  namespace
-  {
-    inline bool valid(core::Square sq)
-    {
-      return sq != core::NO_SQUARE;
-    }
-  } // namespace
-
   AttackSystem::AttackSystem(view::GameView &view, model::ChessGame &game, LegalMoveCache &legal)
       : m_view(view), m_game(game), m_legal(legal)
   {
@@ -26,7 +17,7 @@ namespace lilia::controller
   const std::vector<core::Square> &AttackSystem::attacks(core::Square pieceSq) const
   {
     m_out.clear();
-    if (!valid(pieceSq))
+    if (!core::validSquare(pieceSq))
       return m_out;
 
     const core::PieceType vType = m_view.getPieceType(pieceSq);
@@ -57,6 +48,7 @@ namespace lilia::controller
       }
 
       m_pseudo.clear();
+      m_pseudo = m_game.generatePseudoLegalMoves();
       m_movegen.generatePseudoLegalMoves(board, st, m_pseudo);
       for (const auto &m : m_pseudo)
         if (m.from() == pieceSq)
diff --git a/src/lilia/controller/subsystems/board_input_system.cpp b/src/lilia/controller/subsystems/board_input_system.cpp
index 2d31cc8..7c3ba60 100755
--- a/src/lilia/controller/subsystems/board_input_system.cpp
+++ b/src/lilia/controller/subsystems/board_input_system.cpp
@@ -3,382 +3,469 @@
 #include <SFML/Window/Mouse.hpp>
 
 #include "lilia/controller/game_manager.hpp"
-#include "lilia/controller/subsystems/attack_system.hpp"
 #include "lilia/controller/subsystems/legal_move_cache.hpp"
 #include "lilia/controller/subsystems/premove_system.hpp"
 #include "lilia/model/chess_game.hpp"
 
-namespace lilia::controller {
-
-namespace {
-inline bool valid(core::Square sq) {
-  return sq != core::NO_SQUARE;
-}
-}  // namespace
-
-BoardInputSystem::BoardInputSystem(view::GameView& view, model::ChessGame& game,
-                                   InputManager& input, SelectionManager& sel,
-                                   view::sound::SoundManager& sfx, AttackSystem& attacks,
-                                   PremoveSystem& premove, LegalMoveCache& legal)
-    : m_view(view),
-      m_game(game),
-      m_input(input),
-      m_sel(sel),
-      m_sfx(sfx),
-      m_attacks(attacks),
-      m_premove(premove),
-      m_legal(legal) {}
-
-void BoardInputSystem::bindInputCallbacks() {
-  m_input.setOnClick([this](core::MousePos pos) { onClick(pos); });
-  m_input.setOnDrag([this](core::MousePos s, core::MousePos c) { onDrag(s, c); });
-  m_input.setOnDrop([this](core::MousePos s, core::MousePos e) { onDrop(s, e); });
-}
-
-void BoardInputSystem::onMouseMove(core::MousePos pos) {
-  if (m_dragging || m_mouse_down) {
-    m_view.setHandClosedCursor();
-    return;
+namespace lilia::controller
+{
+
+  namespace
+  {
+    inline bool valid(core::Square sq)
+    {
+      return sq != core::NO_SQUARE;
+    }
+  } // namespace
+
+  BoardInputSystem::BoardInputSystem(view::GameView &view, model::ChessGame &game,
+                                     InputManager &input, SelectionManager &sel,
+                                     view::sound::SoundManager &sfx, PremoveSystem &premove, AttackSystem &att)
+      : m_view(view),
+        m_game(game),
+        m_input(input),
+        m_sel(sel),
+        m_sfx(sfx),
+        m_premove(premove),
+        m_attacks(att)
+  {
   }
 
-  const core::Square sq = m_view.mousePosToSquare(pos);
-  if (m_view.hasPieceOnSquare(sq) && !m_view.isInPromotionSelection())
-    m_view.setHandOpenCursor();
-  else
-    m_view.setDefaultCursor();
-}
+  void BoardInputSystem::bindInputCallbacks()
+  {
+    m_input.setOnClick([this](core::MousePos pos)
+                       { onClick(pos); });
+    m_input.setOnDrag([this](core::MousePos s, core::MousePos c)
+                      { onDrag(s, c); });
+    m_input.setOnDrop([this](core::MousePos s, core::MousePos e)
+                      { onDrop(s, e); });
+  }
 
-void BoardInputSystem::onMousePressed(core::MousePos pos) {
-  m_mouse_down = true;
+  void BoardInputSystem::onMouseMove(core::MousePos pos)
+  {
+    if (m_dragging || m_mouse_down)
+    {
+      m_view.setHandClosedCursor();
+      return;
+    }
 
-  if (m_view.isInPromotionSelection()) {
-    m_view.setHandClosedCursor();
-    return;
+    const core::Square sq = m_view.mousePosToSquare(pos);
+    if (m_view.hasPieceOnSquare(sq) && !m_view.isInPromotionSelection())
+      m_view.setHandOpenCursor();
+    else
+      m_view.setDefaultCursor();
   }
 
-  const core::Square sq = m_view.mousePosToSquare(pos);
-  m_selection_changed_on_press = false;
+  void BoardInputSystem::onMousePressed(core::MousePos pos)
+  {
+    m_mouse_down = true;
 
-  if (!m_premove.hasVirtualPiece(sq)) {
-    m_view.setDefaultCursor();
-    m_view.clearRightClickHighlights();
-    return;
-  }
+    if (m_view.isInPromotionSelection())
+    {
+      m_view.setHandClosedCursor();
+      return;
+    }
+
+    const core::Square sq = m_view.mousePosToSquare(pos);
+    m_selection_changed_on_press = false;
+
+    if (!m_premove.hasVirtualPiece(sq))
+    {
+      m_view.setDefaultCursor();
+      m_view.clearRightClickHighlights();
+      return;
+    }
 
-  const core::Square currentSelected = m_sel.getSelectedSquare();
-  const bool selectionWasDifferent = (currentSelected != sq);
+    const core::Square currentSelected = m_sel.getSelectedSquare();
+    const bool selectionWasDifferent = (currentSelected != sq);
 
-  if (currentSelected != core::NO_SQUARE && currentSelected != sq) {
-    m_preview_active = true;
-    m_prev_selected_before_preview = currentSelected;
+    if (currentSelected != core::NO_SQUARE && currentSelected != sq)
+    {
+      m_preview_active = true;
+      m_prev_selected_before_preview = currentSelected;
+
+      if (!tryMove(currentSelected, sq))
+      {
+        m_view.clearNonPremoveHighlights();
+        m_sel.highlightLastMove();
+        m_sel.selectSquare(sq);
+        m_sel.hoverSquare(sq);
+        if (isHumanPiece(sq))
+          showAttacks(m_attacks.attacks(sq));
+      }
+    }
+    else
+    {
+      m_preview_active = false;
+      m_prev_selected_before_preview = core::NO_SQUARE;
 
-    if (!tryMove(currentSelected, sq)) {
       m_view.clearNonPremoveHighlights();
       m_sel.highlightLastMove();
       m_sel.selectSquare(sq);
       m_sel.hoverSquare(sq);
-      if (isHumanPiece(sq)) showAttacks(m_attacks.attacks(sq));
+      if (isHumanPiece(sq))
+        showAttacks(m_attacks.attacks(sq));
+    }
+
+    if (!tryMove(currentSelected, sq))
+    {
+      m_dragging = true;
+      m_drag_from = sq;
+      m_view.setPieceToMouseScreenPos(sq, pos);
+      m_view.playPiecePlaceHolderAnimation(sq);
+    }
+
+    m_selection_changed_on_press = selectionWasDifferent && (m_sel.getSelectedSquare() == sq);
+  }
+
+  void BoardInputSystem::onMouseReleased(core::MousePos pos)
+  {
+    m_mouse_down = false;
+    if (m_dragging)
+    {
+      m_dragging = false;
+      m_drag_from = core::NO_SQUARE;
+      m_view.clearDraggingPiece();
     }
-  } else {
     m_preview_active = false;
     m_prev_selected_before_preview = core::NO_SQUARE;
+    onMouseMove(pos);
+  }
 
-    m_view.clearNonPremoveHighlights();
+  void BoardInputSystem::onRightPressed(core::MousePos pos)
+  {
+    m_premove.clearAll();
+    m_view.clearAttackHighlights();
     m_sel.highlightLastMove();
-    m_sel.selectSquare(sq);
-    m_sel.hoverSquare(sq);
-    if (isHumanPiece(sq)) showAttacks(m_attacks.attacks(sq));
-  }
 
-  if (!tryMove(currentSelected, sq)) {
-    m_dragging = true;
-    m_drag_from = sq;
-    m_view.setPieceToMouseScreenPos(sq, pos);
-    m_view.playPiecePlaceHolderAnimation(sq);
+    m_right_mouse_down = true;
+    m_right_press_time = std::chrono::steady_clock::now();
+    m_right_drag_from = m_view.mousePosToSquare(pos);
   }
 
-  m_selection_changed_on_press = selectionWasDifferent && (m_sel.getSelectedSquare() == sq);
-}
+  void BoardInputSystem::onRightReleased(core::MousePos pos)
+  {
+    if (!m_right_mouse_down)
+      return;
+    m_right_mouse_down = false;
 
-void BoardInputSystem::onMouseReleased(core::MousePos pos) {
-  m_mouse_down = false;
-  if (m_dragging) {
-    m_dragging = false;
-    m_drag_from = core::NO_SQUARE;
-    m_view.clearDraggingPiece();
-  }
-  m_preview_active = false;
-  m_prev_selected_before_preview = core::NO_SQUARE;
-  onMouseMove(pos);
-}
-
-void BoardInputSystem::onRightPressed(core::MousePos pos) {
-  m_premove.clearAll();
-  m_view.clearAttackHighlights();
-  m_sel.highlightLastMove();
-
-  m_right_mouse_down = true;
-  m_right_press_time = std::chrono::steady_clock::now();
-  m_right_drag_from = m_view.mousePosToSquare(pos);
-}
-
-void BoardInputSystem::onRightReleased(core::MousePos pos) {
-  if (!m_right_mouse_down) return;
-  m_right_mouse_down = false;
-
-  const core::Square endSq = m_view.mousePosToSquare(pos);
-  const core::Square startSq = m_right_drag_from;
-  m_right_drag_from = core::NO_SQUARE;
-
-  if (!valid(startSq) || !valid(endSq)) return;
-
-  const auto elapsed = std::chrono::steady_clock::now() - m_right_press_time;
-  const bool heldLong =
-      std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count() > 200;
-
-  if (startSq != endSq && heldLong) {
-    m_view.highlightRightClickArrow(startSq, endSq);
-  } else {
-    m_view.highlightRightClickSquare(endSq);
-  }
-}
-
-void BoardInputSystem::onMouseEntered() {
-  m_mouse_down = sf::Mouse::isButtonPressed(sf::Mouse::Left);
-  if (!m_dragging) return;
-
-  const core::MousePos mp = m_view.getMousePosition();
-  if (!m_mouse_down) {
-    m_view.animationSnapAndReturn(m_drag_from, mp);
-    m_dragging = false;
-    m_drag_from = core::NO_SQUARE;
-    m_view.clearDraggingPiece();
-    m_input.cancelDrag();
-    m_view.setDefaultCursor();
-  } else {
-    m_view.setPieceToMouseScreenPos(m_drag_from, mp);
+    const core::Square endSq = m_view.mousePosToSquare(pos);
+    const core::Square startSq = m_right_drag_from;
+    m_right_drag_from = core::NO_SQUARE;
+
+    if (!valid(startSq) || !valid(endSq))
+      return;
+
+    const auto elapsed = std::chrono::steady_clock::now() - m_right_press_time;
+    const bool heldLong =
+        std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count() > 200;
+
+    if (startSq != endSq && heldLong)
+    {
+      m_view.highlightRightClickArrow(startSq, endSq);
+    }
+    else
+    {
+      m_view.highlightRightClickSquare(endSq);
+    }
   }
-}
 
-void BoardInputSystem::onLostFocus() {
-  m_mouse_down = false;
-  if (m_dragging) {
+  void BoardInputSystem::onMouseEntered()
+  {
+    m_mouse_down = sf::Mouse::isButtonPressed(sf::Mouse::Left);
+    if (!m_dragging)
+      return;
+
     const core::MousePos mp = m_view.getMousePosition();
-    m_view.animationSnapAndReturn(m_drag_from, mp);
-    m_dragging = false;
-    m_drag_from = core::NO_SQUARE;
-    m_view.clearDraggingPiece();
-    m_input.cancelDrag();
-  }
-  m_view.setDefaultCursor();
-}
-
-bool BoardInputSystem::isHumanPiece(core::Square sq) const {
-  if (!valid(sq)) return false;
-  const auto pc = m_premove.pieceConsideringPremoves(sq);
-  if (pc.type == core::PieceType::None) return false;
-  return (!m_game_manager) ? true : m_game_manager->isHuman(pc.color);
-}
-
-bool BoardInputSystem::tryMove(core::Square a, core::Square b) const {
-  if (!isHumanPiece(a)) return false;
-  for (auto att : m_attacks.attacks(a))
-    if (att == b) return true;
-  return false;
-}
-
-void BoardInputSystem::showAttacks(const std::vector<core::Square>& att) {
-  m_view.clearAttackHighlights();
-  for (auto sq : att) {
-    if (m_premove.hasVirtualPiece(sq))
-      m_view.highlightCaptureSquare(sq);
+    if (!m_mouse_down)
+    {
+      m_view.animationSnapAndReturn(m_drag_from, mp);
+      m_dragging = false;
+      m_drag_from = core::NO_SQUARE;
+      m_view.clearDraggingPiece();
+      m_input.cancelDrag();
+      m_view.setDefaultCursor();
+    }
     else
-      m_view.highlightAttackSquare(sq);
+    {
+      m_view.setPieceToMouseScreenPos(m_drag_from, mp);
+    }
   }
-}
 
-void BoardInputSystem::onClick(core::MousePos mousePos) {
-  if (m_view.isOnFlipIcon(mousePos)) {
-    m_view.toggleBoardOrientation();
-    m_premove.onBoardFlipped();
-    return;
+  void BoardInputSystem::onLostFocus()
+  {
+    m_mouse_down = false;
+    if (m_dragging)
+    {
+      const core::MousePos mp = m_view.getMousePosition();
+      m_view.animationSnapAndReturn(m_drag_from, mp);
+      m_dragging = false;
+      m_drag_from = core::NO_SQUARE;
+      m_view.clearDraggingPiece();
+      m_input.cancelDrag();
+    }
+    m_view.setDefaultCursor();
   }
 
-  const core::Square sq = m_view.mousePosToSquare(mousePos);
-  if (!valid(sq)) {
-    m_selection_changed_on_press = false;
-    if (m_sel.getSelectedSquare() != core::NO_SQUARE) m_sel.deselectSquare();
-    return;
+  bool BoardInputSystem::isHumanPiece(core::Square sq) const
+  {
+    if (!valid(sq))
+      return false;
+    const auto pc = m_premove.pieceConsideringPremoves(sq);
+    if (pc.type == core::PieceType::None)
+      return false;
+    return (!m_game_manager) ? true : m_game_manager->isHuman(pc.color);
   }
 
-  if (m_view.hasPieceOnSquare(sq)) {
-    m_view.endAnimation(sq);
-    m_view.setPieceToSquareScreenPos(sq, sq);
+  bool BoardInputSystem::tryMove(core::Square a, core::Square b) const
+  {
+    if (!isHumanPiece(a))
+      return false;
+    for (auto att : m_attacks.attacks(a))
+      if (att == b)
+        return true;
+    return false;
   }
 
-  if (m_selection_changed_on_press && sq == m_sel.getSelectedSquare()) {
-    m_selection_changed_on_press = false;
-    return;
+  void BoardInputSystem::showAttacks(const std::vector<core::Square> &att)
+  {
+    m_view.clearAttackHighlights();
+    for (auto sq : att)
+    {
+      if (m_premove.hasVirtualPiece(sq))
+        m_view.highlightCaptureSquare(sq);
+      else
+        m_view.highlightAttackSquare(sq);
+    }
   }
-  m_selection_changed_on_press = false;
 
-  if (m_view.isInPromotionSelection()) {
-    const core::PieceType promoType = m_view.getSelectedPromotion(mousePos);
-    m_view.removePromotionSelection();
+  void BoardInputSystem::onClick(core::MousePos mousePos)
+  {
+    if (m_view.isOnFlipIcon(mousePos))
+    {
+      m_view.toggleBoardOrientation();
+      m_premove.onBoardFlipped();
+      return;
+    }
 
-    if (m_premove.isPendingPromotionSelection()) {
-      m_premove.completePendingPromotion(promoType);
-      m_sel.deselectSquare();
+    const core::Square sq = m_view.mousePosToSquare(mousePos);
+    if (!valid(sq))
+    {
+      m_selection_changed_on_press = false;
+      if (m_sel.getSelectedSquare() != core::NO_SQUARE)
+        m_sel.deselectSquare();
       return;
     }
 
-    if (m_game_manager) m_game_manager->completePendingPromotion(promoType);
-    m_sel.deselectSquare();
-    return;
-  }
+    if (m_view.hasPieceOnSquare(sq))
+    {
+      m_view.endAnimation(sq);
+      m_view.setPieceToSquareScreenPos(sq, sq);
+    }
 
-  if (m_sel.getSelectedSquare() != core::NO_SQUARE) {
-    const auto st = m_game.getGameState();
-    const auto selPiece = m_premove.pieceConsideringPremoves(m_sel.getSelectedSquare());
+    if (m_selection_changed_on_press && sq == m_sel.getSelectedSquare())
+    {
+      m_selection_changed_on_press = false;
+      return;
+    }
+    m_selection_changed_on_press = false;
 
-    const bool ownTurnAndPiece =
-        (selPiece.type != core::PieceType::None && st.sideToMove == selPiece.color &&
-         (!m_game_manager || m_game_manager->isHuman(st.sideToMove)));
+    if (m_view.isInPromotionSelection())
+    {
+      const core::PieceType promoType = m_view.getSelectedPromotion(mousePos);
+      m_view.removePromotionSelection();
 
-    const core::Color humanColor = ~st.sideToMove;
-    const bool canPremove =
-        (selPiece.type != core::PieceType::None && selPiece.color == humanColor &&
-         (!m_game_manager || m_game_manager->isHuman(humanColor)));
+      if (m_premove.isPendingPromotionSelection())
+      {
+        m_premove.completePendingPromotion(promoType);
+        m_sel.deselectSquare();
+        return;
+      }
 
-    if (ownTurnAndPiece && tryMove(m_sel.getSelectedSquare(), sq)) {
       if (m_game_manager)
-        (void)m_game_manager->requestUserMove(m_sel.getSelectedSquare(), sq, true);
+        m_game_manager->completePendingPromotion(promoType);
       m_sel.deselectSquare();
       return;
     }
 
-    if (!ownTurnAndPiece && canPremove) {
-      if (sq == m_sel.getSelectedSquare()) {
-        m_sel.deselectSquare();
-      } else {
-        m_premove.enqueue(m_sel.getSelectedSquare(), sq);
+    if (m_sel.getSelectedSquare() != core::NO_SQUARE)
+    {
+      const auto st = m_game.getGameState();
+      const auto selPiece = m_premove.pieceConsideringPremoves(m_sel.getSelectedSquare());
+
+      const bool ownTurnAndPiece =
+          (selPiece.type != core::PieceType::None && st.sideToMove == selPiece.color &&
+           (!m_game_manager || m_game_manager->isHuman(st.sideToMove)));
+
+      const core::Color humanColor = ~st.sideToMove;
+      const bool canPremove =
+          (selPiece.type != core::PieceType::None && selPiece.color == humanColor &&
+           (!m_game_manager || m_game_manager->isHuman(humanColor)));
+
+      if (ownTurnAndPiece && tryMove(m_sel.getSelectedSquare(), sq))
+      {
+        if (m_game_manager)
+          (void)m_game_manager->requestUserMove(m_sel.getSelectedSquare(), sq, true);
         m_sel.deselectSquare();
+        return;
+      }
+
+      if (!ownTurnAndPiece && canPremove)
+      {
+        if (sq == m_sel.getSelectedSquare())
+        {
+          m_sel.deselectSquare();
+        }
+        else
+        {
+          m_premove.enqueue(m_sel.getSelectedSquare(), sq);
+          m_sel.deselectSquare();
+        }
+        return;
       }
-      return;
-    }
 
-    if (m_premove.hasVirtualPiece(sq)) {
-      if (sq == m_sel.getSelectedSquare()) {
+      if (m_premove.hasVirtualPiece(sq))
+      {
+        if (sq == m_sel.getSelectedSquare())
+        {
+          m_sel.deselectSquare();
+        }
+        else
+        {
+          m_view.clearNonPremoveHighlights();
+          m_sel.highlightLastMove();
+          m_sel.selectSquare(sq);
+          if (isHumanPiece(sq))
+            showAttacks(m_attacks.attacks(sq));
+        }
+      }
+      else
+      {
         m_sel.deselectSquare();
-      } else {
-        m_view.clearNonPremoveHighlights();
-        m_sel.highlightLastMove();
-        m_sel.selectSquare(sq);
-        if (isHumanPiece(sq)) showAttacks(m_attacks.attacks(sq));
       }
-    } else {
-      m_sel.deselectSquare();
+      return;
     }
-    return;
-  }
 
-  if (m_premove.hasVirtualPiece(sq)) {
-    m_view.clearNonPremoveHighlights();
-    m_sel.highlightLastMove();
-    m_sel.selectSquare(sq);
-    if (isHumanPiece(sq)) showAttacks(m_attacks.attacks(sq));
+    if (m_premove.hasVirtualPiece(sq))
+    {
+      m_view.clearNonPremoveHighlights();
+      m_sel.highlightLastMove();
+      m_sel.selectSquare(sq);
+      if (isHumanPiece(sq))
+        showAttacks(m_attacks.attacks(sq));
+    }
   }
-}
 
-void BoardInputSystem::onDrag(core::MousePos start, core::MousePos current) {
-  const core::Square sqStart = m_view.mousePosToSquare(start);
-  const core::MousePos clamped = m_view.clampPosToBoard(current);
-  const core::Square sqMous = m_view.mousePosToSquare(clamped);
+  void BoardInputSystem::onDrag(core::MousePos start, core::MousePos current)
+  {
+    const core::Square sqStart = m_view.mousePosToSquare(start);
+    const core::MousePos clamped = m_view.clampPosToBoard(current);
+    const core::Square sqMous = m_view.mousePosToSquare(clamped);
 
-  if (m_view.isInPromotionSelection()) return;
-  if (!m_premove.hasVirtualPiece(sqStart)) return;
-  if (!m_dragging) return;
-
-  if (m_sel.getSelectedSquare() != sqStart) {
-    m_view.clearNonPremoveHighlights();
-    m_sel.highlightLastMove();
-    m_sel.selectSquare(sqStart);
-    if (isHumanPiece(sqStart)) showAttacks(m_attacks.attacks(sqStart));
-  }
-
-  if (m_sel.getHoveredSquare() != sqMous) m_sel.dehoverSquare();
-  m_sel.hoverSquare(sqMous);
+    if (m_view.isInPromotionSelection())
+      return;
+    if (!m_premove.hasVirtualPiece(sqStart))
+      return;
+    if (!m_dragging)
+      return;
 
-  m_view.setPieceToMouseScreenPos(sqStart, current);
-  m_view.playPiecePlaceHolderAnimation(sqStart);
-}
+    if (m_sel.getSelectedSquare() != sqStart)
+    {
+      m_view.clearNonPremoveHighlights();
+      m_sel.highlightLastMove();
+      m_sel.selectSquare(sqStart);
+      if (isHumanPiece(sqStart))
+        showAttacks(m_attacks.attacks(sqStart));
+    }
 
-void BoardInputSystem::onDrop(core::MousePos start, core::MousePos end) {
-  const core::Square from = m_view.mousePosToSquare(start);
-  const core::Square to = m_view.mousePosToSquare(m_view.clampPosToBoard(end));
+    if (m_sel.getHoveredSquare() != sqMous)
+      m_sel.dehoverSquare();
+    m_sel.hoverSquare(sqMous);
 
-  m_sel.dehoverSquare();
+    m_view.setPieceToMouseScreenPos(sqStart, current);
+    m_view.playPiecePlaceHolderAnimation(sqStart);
+  }
 
-  if (m_view.isInPromotionSelection()) return;
+  void BoardInputSystem::onDrop(core::MousePos start, core::MousePos end)
+  {
+    const core::Square from = m_view.mousePosToSquare(start);
+    const core::Square to = m_view.mousePosToSquare(m_view.clampPosToBoard(end));
 
-  if (!m_premove.hasVirtualPiece(from)) {
-    m_sel.deselectSquare();
-    m_preview_active = false;
-    m_prev_selected_before_preview = core::NO_SQUARE;
-    return;
-  }
+    m_sel.dehoverSquare();
 
-  m_view.endAnimation(from);
+    if (m_view.isInPromotionSelection())
+      return;
 
-  bool accepted = false;
-  bool setPremove = false;
+    if (!m_premove.hasVirtualPiece(from))
+    {
+      m_sel.deselectSquare();
+      m_preview_active = false;
+      m_prev_selected_before_preview = core::NO_SQUARE;
+      return;
+    }
 
-  const auto st = m_game.getGameState();
-  const core::Color fromColor = m_premove.pieceConsideringPremoves(from).color;
-  const bool humanTurnNow = (m_game_manager && m_game_manager->isHuman(st.sideToMove));
-  const bool movingOwnTurnPiece = humanTurnNow && (fromColor == st.sideToMove);
+    m_view.endAnimation(from);
 
-  const core::Color humanNextColor = ~st.sideToMove;
-  const bool humanNextIsHuman = (!m_game_manager || m_game_manager->isHuman(humanNextColor));
+    bool accepted = false;
+    bool setPremove = false;
 
-  if (from != to) {
-    if (movingOwnTurnPiece && tryMove(from, to)) {
-      if (m_game_manager) accepted = m_game_manager->requestUserMove(from, to, false);
-    } else if (fromColor == humanNextColor && humanNextIsHuman) {
-      setPremove = m_premove.enqueue(from, to);
+    const auto st = m_game.getGameState();
+    const core::Color fromColor = m_premove.pieceConsideringPremoves(from).color;
+    const bool humanTurnNow = (m_game_manager && m_game_manager->isHuman(st.sideToMove));
+    const bool movingOwnTurnPiece = humanTurnNow && (fromColor == st.sideToMove);
+
+    const core::Color humanNextColor = ~st.sideToMove;
+    const bool humanNextIsHuman = (!m_game_manager || m_game_manager->isHuman(humanNextColor));
+
+    if (from != to)
+    {
+      if (movingOwnTurnPiece && tryMove(from, to))
+      {
+        if (m_game_manager)
+          accepted = m_game_manager->requestUserMove(from, to, false);
+      }
+      else if (fromColor == humanNextColor && humanNextIsHuman)
+      {
+        setPremove = m_premove.enqueue(from, to);
+      }
     }
-  }
 
-  if (!accepted) {
-    if (!setPremove) {
-      m_view.setPieceToSquareScreenPos(from, from);
-      m_view.animationSnapAndReturn(from, end);
+    if (!accepted)
+    {
+      if (!setPremove)
+      {
+        m_view.setPieceToSquareScreenPos(from, from);
+        m_view.animationSnapAndReturn(from, end);
 
-      m_view.clearNonPremoveHighlights();
-      m_sel.highlightLastMove();
-      m_sel.selectSquare(m_preview_active && valid(m_prev_selected_before_preview) &&
-                                 m_prev_selected_before_preview != from
-                             ? m_prev_selected_before_preview
-                             : from);
-      if (isHumanPiece(m_sel.getSelectedSquare()))
-        showAttacks(m_attacks.attacks(m_sel.getSelectedSquare()));
-    } else {
-      m_sel.deselectSquare();
+        m_view.clearNonPremoveHighlights();
+        m_sel.highlightLastMove();
+        m_sel.selectSquare(m_preview_active && valid(m_prev_selected_before_preview) &&
+                                   m_prev_selected_before_preview != from
+                               ? m_prev_selected_before_preview
+                               : from);
+        if (isHumanPiece(m_sel.getSelectedSquare()))
+          showAttacks(m_attacks.attacks(m_sel.getSelectedSquare()));
+      }
+      else
+      {
+        m_sel.deselectSquare();
+      }
     }
-  }
 
-  m_preview_active = false;
-  m_prev_selected_before_preview = core::NO_SQUARE;
-}
+    m_preview_active = false;
+    m_prev_selected_before_preview = core::NO_SQUARE;
+  }
 
-void BoardInputSystem::refreshActiveHighlights() {
-  core::Square activeSq = core::NO_SQUARE;
-  if (m_dragging && valid(m_drag_from))
-    activeSq = m_drag_from;
-  else if (valid(m_sel.getSelectedSquare()))
-    activeSq = m_sel.getSelectedSquare();
+  void BoardInputSystem::refreshActiveHighlights()
+  {
+    core::Square activeSq = core::NO_SQUARE;
+    if (m_dragging && valid(m_drag_from))
+      activeSq = m_drag_from;
+    else if (valid(m_sel.getSelectedSquare()))
+      activeSq = m_sel.getSelectedSquare();
 
-  if (valid(activeSq) && isHumanPiece(activeSq)) showAttacks(m_attacks.attacks(activeSq));
-}
+    if (valid(activeSq) && isHumanPiece(activeSq))
+      showAttacks(m_attacks.attacks(activeSq));
+  }
 
-}  // namespace lilia::controller
+} // namespace lilia::controller
diff --git a/src/lilia/controller/subsystems/clock_system.cpp b/src/lilia/controller/subsystems/clock_system.cpp
index 2999cfc..27364d2 100755
--- a/src/lilia/controller/subsystems/clock_system.cpp
+++ b/src/lilia/controller/subsystems/clock_system.cpp
@@ -5,8 +5,8 @@
 namespace lilia::controller
 {
 
-  ClockSystem::ClockSystem(view::GameView &view, model::ChessGame &game)
-      : m_view(view), m_game(game) {}
+  ClockSystem::ClockSystem(view::GameView &view)
+      : m_view(view) {}
 
   void ClockSystem::reset(bool enabled, int baseSeconds, int incrementSeconds)
   {
diff --git a/src/lilia/controller/subsystems/game_end_system.cpp b/src/lilia/controller/subsystems/game_end_system.cpp
index 8257782..ca1d1e7 100755
--- a/src/lilia/controller/subsystems/game_end_system.cpp
+++ b/src/lilia/controller/subsystems/game_end_system.cpp
@@ -1,6 +1,5 @@
 #include "lilia/controller/subsystems/game_end_system.hpp"
 
-#include "lilia/model/chess_game.hpp"
 #include "lilia/controller/subsystems/clock_system.hpp"
 #include "lilia/controller/subsystems/premove_system.hpp"
 #include "lilia/model/analysis/result_utils.hpp"
@@ -8,9 +7,9 @@
 namespace lilia::controller
 {
 
-  GameEndSystem::GameEndSystem(view::GameView &view, model::ChessGame &game,
+  GameEndSystem::GameEndSystem(view::GameView &view,
                                view::sound::SoundManager &sfx)
-      : m_view(view), m_game(game), m_sfx(sfx) {}
+      : m_view(view), m_sfx(sfx) {}
 
   void GameEndSystem::show(core::GameResult res, core::Color sideToMove, bool whiteIsBot,
                            bool blackIsBot, ClockSystem &clock, PremoveSystem &premove)
diff --git a/src/lilia/controller/subsystems/history_system.cpp b/src/lilia/controller/subsystems/history_system.cpp
index eed46c6..27776f4 100755
--- a/src/lilia/controller/subsystems/history_system.cpp
+++ b/src/lilia/controller/subsystems/history_system.cpp
@@ -11,8 +11,8 @@ namespace lilia::controller
 {
 
   HistorySystem::HistorySystem(view::GameView &view, model::ChessGame &game, SelectionManager &sel,
-                               view::sound::SoundManager &sfx, std::atomic<int> &evalCp)
-      : m_view(view), m_game(game), m_sel(sel), m_sfx(sfx), m_eval_cp(evalCp) {}
+                               view::sound::SoundManager &sfx)
+      : m_view(view), m_game(game), m_sel(sel), m_sfx(sfx) {}
 
   void HistorySystem::reset(const std::string &startFen, const model::analysis::TimeView &startTime)
   {
@@ -36,7 +36,6 @@ namespace lilia::controller
 
     // eval: start neutral or current live value; choose one:
     m_view.resetEvalBar();
-    m_view.updateEval(m_eval_cp.load());
 
     stashSelectedPiece();
     restoreSelectedPiece();
@@ -57,9 +56,6 @@ namespace lilia::controller
     m_fen_index = m_fen_history.size() - 1;
     m_view.setBoardFen(m_fen_history[m_fen_index]);
 
-    // at head: show live eval
-    m_view.updateEval(m_eval_cp.load());
-
     m_view.selectMove(m_fen_index ? m_fen_index - 1 : kInvalidMoveIdx);
     m_view.clearAllHighlights();
 
@@ -113,9 +109,6 @@ namespace lilia::controller
     m_view.updateFen(fenAfter);
     m_view.selectMove(m_fen_index ? m_fen_index - 1 : kInvalidMoveIdx);
 
-    // show live eval (engine callback updates m_eval_cp asynchronously)
-    m_view.updateEval(m_eval_cp.load());
-
     if (m_game.getResult() != core::GameResult::ONGOING)
     {
       m_view.setEvalResult(model::analysis::result_string(m_game.getResult(), m_game.getGameState().sideToMove, /*forPgn=*/false));
@@ -373,15 +366,6 @@ namespace lilia::controller
       m_view.restoreRightClickHighlights();
   }
 
-  void HistorySystem::updateEvalAtHead()
-  {
-    if (m_fen_history.empty())
-      return;
-    if (!atHead())
-      return;
-    m_view.updateEval(m_eval_cp.load());
-  }
-
   model::analysis::GameRecord HistorySystem::toRecord() const
   {
     model::analysis::GameRecord rec{};
@@ -481,7 +465,7 @@ namespace lilia::controller
       else
         effect = view::sound::Effect::EnemyMove;
 
-      MoveView mvInfo{mv, moverColorBefore, capturedType, effect, 0};
+      MoveView mvInfo{mv, moverColorBefore, capturedType, effect};
 
       m_move_history.push_back(mvInfo);
       m_fen_history.push_back(fenAfter);
diff --git a/src/lilia/controller/subsystems/legal_move_cache.cpp b/src/lilia/controller/subsystems/legal_move_cache.cpp
index ef3d255..2137888 100755
--- a/src/lilia/controller/subsystems/legal_move_cache.cpp
+++ b/src/lilia/controller/subsystems/legal_move_cache.cpp
@@ -2,25 +2,34 @@
 
 #include "lilia/model/chess_game.hpp"
 
-namespace lilia::controller {
+namespace lilia::controller
+{
 
-const std::vector<model::Move>& LegalMoveCache::legal() const {
-  if (!m_cached) m_cached = &m_game.generateLegalMoves();
-  return *m_cached;
-}
+  const std::vector<model::Move> &LegalMoveCache::legal() const
+  {
+    if (!m_cached)
+      m_cached = &m_game.generateLegalMoves();
+    return *m_cached;
+  }
 
-bool LegalMoveCache::contains(core::Square from, core::Square to) const {
-  for (const auto& m : legal()) {
-    if (m.from() == from && m.to() == to) return true;
+  bool LegalMoveCache::contains(core::Square from, core::Square to) const
+  {
+    for (const auto &m : legal())
+    {
+      if (m.from() == from && m.to() == to)
+        return true;
+    }
+    return false;
   }
-  return false;
-}
 
-bool LegalMoveCache::isPromotion(core::Square from, core::Square to) const {
-  for (const auto& m : legal()) {
-    if (m.from() == from && m.to() == to && m.promotion() != core::PieceType::None) return true;
+  bool LegalMoveCache::isPromotion(core::Square from, core::Square to) const
+  {
+    for (const auto &m : legal())
+    {
+      if (m.from() == from && m.to() == to && m.promotion() != core::PieceType::None)
+        return true;
+    }
+    return false;
   }
-  return false;
-}
 
-}  // namespace lilia::controller
+} // namespace lilia::controller
diff --git a/src/lilia/controller/subsystems/move_execution_system.cpp b/src/lilia/controller/subsystems/move_execution_system.cpp
index eae2531..92662f8 100755
--- a/src/lilia/controller/subsystems/move_execution_system.cpp
+++ b/src/lilia/controller/subsystems/move_execution_system.cpp
@@ -21,13 +21,12 @@ namespace lilia::controller
   } // namespace
 
   MoveExecutionSystem::MoveExecutionSystem(view::GameView &view, model::ChessGame &game,
-                                           view::sound::SoundManager &sfx, std::atomic<int> &evalCp,
+                                           view::sound::SoundManager &sfx,
                                            LegalMoveCache &legal, HistorySystem &history,
                                            ClockSystem &clock, PremoveSystem &premove)
       : m_view(view),
         m_game(game),
         m_sfx(sfx),
-        m_eval_cp(evalCp),
         m_legal(legal),
         m_history(history),
         m_clock(clock),
@@ -119,7 +118,7 @@ namespace lilia::controller
     const model::analysis::TimeView tv =
         m_clock.enabled() ? m_clock.snapshot(sideToMoveNow) : model::analysis::TimeView{0.f, 0.f, sideToMoveNow};
 
-    MoveView mvInfo{move, moverColorBefore, capturedType, effect, m_eval_cp.load()};
+    MoveView mvInfo{move, moverColorBefore, capturedType, effect};
     m_history.onMoveCommitted(mvInfo, m_game.getFen(), tv);
 
     m_premove.scheduleFromQueueIfTurnMatches();
diff --git a/src/lilia/controller/subsystems/premove_system.cpp b/src/lilia/controller/subsystems/premove_system.cpp
index d4e2a32..5a234b0 100755
--- a/src/lilia/controller/subsystems/premove_system.cpp
+++ b/src/lilia/controller/subsystems/premove_system.cpp
@@ -3,20 +3,13 @@
 #include <cmath>
 
 #include "lilia/controller/game_manager.hpp"
+#include "lilia/model/chess_game.hpp"
 #include "lilia/controller/subsystems/legal_move_cache.hpp"
 #include "lilia/view/ui/screens/game_view.hpp"
 
 namespace lilia::controller
 {
 
-  namespace
-  {
-    inline bool valid(core::Square sq)
-    {
-      return sq != core::NO_SQUARE;
-    }
-  } // namespace
-
   PremoveSystem::PremoveSystem(view::GameView &view, model::ChessGame &game,
                                view::sound::SoundManager &sfx, LegalMoveCache &legal)
       : m_view(view), m_game(game), m_sfx(sfx), m_legal(legal)
@@ -26,14 +19,14 @@ namespace lilia::controller
 
   bool PremoveSystem::hasVirtualPiece(core::Square sq) const
   {
-    if (!valid(sq))
+    if (!core::validSquare(sq))
       return false;
     return pieceConsideringPremoves(sq).type != core::PieceType::None;
   }
 
   model::bb::Piece PremoveSystem::pieceConsideringPremoves(core::Square sq) const
   {
-    if (!valid(sq))
+    if (!core::validSquare(sq))
       return {};
     if (!m_queue.empty())
     {
@@ -100,7 +93,7 @@ namespace lilia::controller
 
   bool PremoveSystem::isPseudoLegal(core::Square from, core::Square to) const
   {
-    if (!valid(from) || !valid(to))
+    if (!core::validSquare(from) || !core::validSquare(to))
       return false;
 
     model::Position pos = positionAfterPremoves();
@@ -367,7 +360,7 @@ namespace lilia::controller
 
   bool PremoveSystem::currentLegal(core::Square from, core::Square to) const
   {
-    if (!valid(from) || !valid(to))
+    if (!core::validSquare(from) || !core::validSquare(to))
       return false;
     const auto st = m_game.getGameState();
     const auto pc = m_game.getPiece(from);
diff --git a/src/lilia/model/analysis/replay_info.cpp b/src/lilia/model/analysis/replay_info.cpp
index a4c6ac4..6c27b2b 100644
--- a/src/lilia/model/analysis/replay_info.cpp
+++ b/src/lilia/model/analysis/replay_info.cpp
@@ -18,15 +18,14 @@ namespace lilia::model::analysis
     info.date = tagOr(rec, "Date", "");
     info.round = tagOr(rec, "Round", "");
 
-    info.white.name = tagOr(rec, "White", "White");
-    info.black.name = tagOr(rec, "Black", "Black");
+    info.white_info.name = tagOr(rec, "White", "White");
+    info.black_info.name = tagOr(rec, "Black", "Black");
 
-    info.white.elo = tagOr(rec, "WhiteElo", "");
-    info.black.elo = tagOr(rec, "BlackElo", "");
+    info.white_info.elo = tagOr(rec, "WhiteElo", "");
+    info.black_info.elo = tagOr(rec, "BlackElo", "");
 
-    // Icons: leave empty here; controller/view applies a safe default.
-    info.white.iconPath.clear();
-    info.black.iconPath.clear();
+    info.white_info.icon_name.clear();
+    info.black_info.icon_name.clear();
 
     info.result = rec.result.empty() ? tagOr(rec, "Result", "*") : rec.result;
 
diff --git a/src/lilia/model/chess_game.cpp b/src/lilia/model/chess_game.cpp
index 415459d..309dbfd 100755
--- a/src/lilia/model/chess_game.cpp
+++ b/src/lilia/model/chess_game.cpp
@@ -241,6 +241,13 @@ namespace lilia::model
     return m_legal_moves;
   }
 
+  const std::vector<Move> &ChessGame::generatePseudoLegalMoves()
+  {
+    m_pseudo_moves.clear();
+    m_move_gen.generatePseudoLegalMoves(m_position.getBoard(), m_position.getState(), m_pseudo_moves);
+    return m_pseudo_moves;
+  }
+
   const GameState &ChessGame::getGameState()
   {
     return m_position.getState();
diff --git a/src/lilia/view/animation/animation_manager.cpp b/src/lilia/view/animation/animation_manager.cpp
index 184c955..3644ef0 100755
--- a/src/lilia/view/animation/animation_manager.cpp
+++ b/src/lilia/view/animation/animation_manager.cpp
@@ -3,94 +3,125 @@
 #include <algorithm>
 #include <iostream>
 
-namespace lilia::view::animation {
+namespace lilia::view::animation
+{
 
-void AnimationManager::add(Entity::ID_type entityID, std::unique_ptr<IAnimation> anim) {
-  addOrReplace(entityID, std::move(anim), AnimLayer::Base);
-}
-
-void AnimationManager::addOrReplace(Entity::ID_type entityID, std::unique_ptr<IAnimation> anim,
-                                    AnimLayer layer) {
-  if (auto it = m_animations.find(entityID); it != m_animations.end()) {
-    m_animations.erase(it);
-  }
-  if (auto it = m_highlight_level_animations.find(entityID);
-      it != m_highlight_level_animations.end()) {
-    m_highlight_level_animations.erase(it);
+  void AnimationManager::add(Entity::ID_type entityID, std::unique_ptr<IAnimation> anim)
+  {
+    addOrReplace(entityID, std::move(anim), AnimLayer::Base);
   }
 
-  if (layer == AnimLayer::Highlight) {
-    m_highlight_level_animations[entityID] = std::move(anim);
-  } else {
-    m_animations[entityID] = std::move(anim);
+  void AnimationManager::addOrReplace(Entity::ID_type entityID, std::unique_ptr<IAnimation> anim,
+                                      AnimLayer layer)
+  {
+    if (auto it = m_animations.find(entityID); it != m_animations.end())
+    {
+      m_animations.erase(it);
+    }
+    if (auto it = m_highlight_level_animations.find(entityID);
+        it != m_highlight_level_animations.end())
+    {
+      m_highlight_level_animations.erase(it);
+    }
+
+    if (layer == AnimLayer::Highlight)
+    {
+      m_highlight_level_animations[entityID] = std::move(anim);
+    }
+    else
+    {
+      m_animations[entityID] = std::move(anim);
+    }
   }
-}
 
-[[nodiscard]] bool AnimationManager::isAnimating(Entity::ID_type entityID) const {
-  return m_animations.find(entityID) != m_animations.end();
-}
+  [[nodiscard]] bool AnimationManager::isAnimating(Entity::ID_type entityID) const
+  {
+    return m_animations.find(entityID) != m_animations.end();
+  }
 
-[[nodiscard]] bool AnimationManager::hasInAnyLayer(Entity::ID_type entityID) const {
-  return m_animations.find(entityID) != m_animations.end() ||
-         m_highlight_level_animations.find(entityID) != m_highlight_level_animations.end();
-}
+  [[nodiscard]] bool AnimationManager::hasInAnyLayer(Entity::ID_type entityID) const
+  {
+    return m_animations.find(entityID) != m_animations.end() ||
+           m_highlight_level_animations.find(entityID) != m_highlight_level_animations.end();
+  }
 
-void AnimationManager::declareHighlightLevel(Entity::ID_type entityID) {
-  if (m_highlight_level_animations.find(entityID) != m_highlight_level_animations.end()) return;
+  void AnimationManager::declareHighlightLevel(Entity::ID_type entityID)
+  {
+    if (m_highlight_level_animations.find(entityID) != m_highlight_level_animations.end())
+      return;
 
-  if (auto it = m_animations.find(entityID); it != m_animations.end()) {
-    m_highlight_level_animations[entityID] = std::move(it->second);
-    m_animations.erase(it);
-    return;
+    if (auto it = m_animations.find(entityID); it != m_animations.end())
+    {
+      m_highlight_level_animations[entityID] = std::move(it->second);
+      m_animations.erase(it);
+      return;
+    }
   }
-}
 
-void AnimationManager::endAnim(Entity::ID_type entityID) {
-  m_animations.erase(entityID);
-}
+  void AnimationManager::endAnim(Entity::ID_type entityID)
+  {
+    m_animations.erase(entityID);
+  }
 
-void AnimationManager::cancelAll(Entity::ID_type entityID) {
-  if (auto it = m_animations.find(entityID); it != m_animations.end()) {
-    m_animations.erase(it);
+  void AnimationManager::cancelAll(Entity::ID_type entityID)
+  {
+    if (auto it = m_animations.find(entityID); it != m_animations.end())
+    {
+      m_animations.erase(it);
+    }
+    if (auto it2 = m_highlight_level_animations.find(entityID);
+        it2 != m_highlight_level_animations.end())
+    {
+      m_highlight_level_animations.erase(it2);
+    }
   }
-  if (auto it2 = m_highlight_level_animations.find(entityID);
-      it2 != m_highlight_level_animations.end()) {
-    m_highlight_level_animations.erase(it2);
+
+  void AnimationManager::cancelAll()
+  {
+    m_animations.clear();
+    m_highlight_level_animations.clear();
   }
-}
-
-void AnimationManager::cancelAll() {
-  m_animations.clear();
-  m_highlight_level_animations.clear();
-}
-
-void AnimationManager::update(float dt) {
-  // Base-Layer
-  for (auto it = m_animations.begin(); it != m_animations.end();) {
-    it->second->update(dt);
-    if (it->second->isFinished()) {
-      it = m_animations.erase(it);
-    } else {
-      ++it;
+
+  void AnimationManager::update(float dt)
+  {
+    // Base-Layer
+    for (auto it = m_animations.begin(); it != m_animations.end();)
+    {
+      it->second->update(dt);
+      if (it->second->isFinished())
+      {
+        it = m_animations.erase(it);
+      }
+      else
+      {
+        ++it;
+      }
     }
-  }
-  // Highlight-Layer
-  for (auto it = m_highlight_level_animations.begin(); it != m_highlight_level_animations.end();) {
-    it->second->update(dt);
-    if (it->second->isFinished()) {
-      it = m_highlight_level_animations.erase(it);
-    } else {
-      ++it;
+    // Highlight-Layer
+    for (auto it = m_highlight_level_animations.begin(); it != m_highlight_level_animations.end();)
+    {
+      it->second->update(dt);
+      if (it->second->isFinished())
+      {
+        it = m_highlight_level_animations.erase(it);
+      }
+      else
+      {
+        ++it;
+      }
     }
   }
-}
 
-void AnimationManager::draw(sf::RenderWindow& window) {
-  for (auto& [id, anim] : m_animations) anim->draw(window);
-}
+  void AnimationManager::draw(sf::RenderWindow &window)
+  {
+    for (auto &[id, anim] : m_animations)
+      anim->draw(window);
+  }
 
-void AnimationManager::highlightLevelDraw(sf::RenderWindow& window) {
-  for (auto& [id, anim] : m_highlight_level_animations) anim->draw(window);
-}
+  void AnimationManager::highlightLevelDraw(sf::RenderWindow &window)
+  {
+    for (auto &[id, anim] : m_highlight_level_animations)
+      anim->draw(window);
+  }
 
-}  // namespace lilia::view::animation
+} // namespace lilia::view::animation
diff --git a/src/lilia/view/animation/promotion_select_animation.cpp b/src/lilia/view/animation/promotion_select_animation.cpp
index b14f428..5b768b0 100755
--- a/src/lilia/view/animation/promotion_select_animation.cpp
+++ b/src/lilia/view/animation/promotion_select_animation.cpp
@@ -2,7 +2,7 @@
 
 #include "lilia/view/ui/render/scene/promotion.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 namespace lilia::view::animation
 {
@@ -13,12 +13,12 @@ namespace lilia::view::animation
   {
     m_promo_mgr_ref.fillOptions(prPos, c, upwards);
 
-    m_white_boarder.setTexture(TextureTable::getInstance().get(std::string{constant::tex::PROMOTION}));
+    m_white_boarder.setTexture(ResourceTable::getInstance().getTexture(std::string{constant::tex::PROMOTION}));
     m_white_boarder.setOriginToCenter();
     m_white_boarder.setPosition(m_promo_mgr_ref.getCenterPosition());
 
     m_white_boarder_shadow.setTexture(
-        TextureTable::getInstance().get(std::string{constant::tex::PROMOTION_SHADOW}));
+        ResourceTable::getInstance().getTexture(std::string{constant::tex::PROMOTION_SHADOW}));
     m_white_boarder_shadow.setOriginToCenter();
     m_white_boarder_shadow.setPosition(m_promo_mgr_ref.getCenterPosition() +
                                        Entity::Position{0.f, +4.f});
diff --git a/src/lilia/view/animation/warning_animation.cpp b/src/lilia/view/animation/warning_animation.cpp
index cb87c01..a409716 100755
--- a/src/lilia/view/animation/warning_animation.cpp
+++ b/src/lilia/view/animation/warning_animation.cpp
@@ -3,7 +3,7 @@
 #include <cmath>
 
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 namespace lilia::view::animation
 {
@@ -11,7 +11,7 @@ namespace lilia::view::animation
   WarningAnim::WarningAnim(Entity::Position ksqPos) : m_warning_highlight(ksqPos)
   {
     m_warning_highlight.setTexture(
-        TextureTable::getInstance().get(std::string{constant::tex::WARNING_HL}));
+        ResourceTable::getInstance().getTexture(std::string{constant::tex::WARNING_HL}));
     m_warning_highlight.setOriginToCenter();
     m_warning_highlight.setScale(constant::SQUARE_PX_SIZE, constant::SQUARE_PX_SIZE);
   }
@@ -33,12 +33,12 @@ namespace lilia::view::animation
     if (phase < m_blink_period)
     {
       m_warning_highlight.setTexture(
-          TextureTable::getInstance().get(std::string{constant::tex::WARNING_HL}));
+          ResourceTable::getInstance().getTexture(std::string{constant::tex::WARNING_HL}));
     }
     else
     {
       m_warning_highlight.setTexture(
-          TextureTable::getInstance().get(std::string{constant::tex::TRANSPARENT}));
+          ResourceTable::getInstance().getTexture(std::string{constant::tex::TRANSPARENT}));
     }
   }
 
diff --git a/src/lilia/view/ui/interaction/cursor_manager.cpp b/src/lilia/view/ui/interaction/cursor_manager.cpp
index 7ae97a8..4885b68 100755
--- a/src/lilia/view/ui/interaction/cursor_manager.cpp
+++ b/src/lilia/view/ui/interaction/cursor_manager.cpp
@@ -4,6 +4,7 @@
 #include <SFML/Graphics/RenderWindow.hpp>
 
 #include "lilia/view/ui/render/render_constants.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 namespace lilia::view
 {
@@ -12,20 +13,13 @@ namespace lilia::view
   {
     m_cursor_default.loadFromSystem(sf::Cursor::Arrow);
 
-    sf::Image openImg;
-    if (openImg.loadFromFile(std::string{constant::path::HAND_OPEN}))
-    {
-      m_cursor_hand_open.loadFromPixels(openImg.getPixelsPtr(), openImg.getSize(),
-                                        {openImg.getSize().x / 3, openImg.getSize().y / 3});
-    }
-
-    sf::Image closedImg;
-    if (closedImg.loadFromFile(std::string{constant::path::HAND_CLOSED}))
-    {
-      m_cursor_hand_closed.loadFromPixels(closedImg.getPixelsPtr(), closedImg.getSize(),
-                                          {closedImg.getSize().x / 3, closedImg.getSize().y / 3});
-    }
+    sf::Image openImg = ResourceTable::getInstance().getImage(std::string{constant::asset_name::HAND_OPEN});
+    m_cursor_hand_open.loadFromPixels(openImg.getPixelsPtr(), openImg.getSize(),
+                                      {openImg.getSize().x / 3, openImg.getSize().y / 3});
 
+    sf::Image closedImg = ResourceTable::getInstance().getImage(std::string{constant::asset_name::HAND_CLOSED});
+    m_cursor_hand_closed.loadFromPixels(closedImg.getPixelsPtr(), closedImg.getSize(),
+                                        {closedImg.getSize().x / 3, closedImg.getSize().y / 3});
     m_window.setMouseCursor(m_cursor_default);
   }
 
diff --git a/src/lilia/view/ui/interaction/highlight_manager.cpp b/src/lilia/view/ui/interaction/highlight_manager.cpp
index 9938c05..d1b4768 100755
--- a/src/lilia/view/ui/interaction/highlight_manager.cpp
+++ b/src/lilia/view/ui/interaction/highlight_manager.cpp
@@ -7,7 +7,7 @@
 
 #include "lilia/view/ui/style/palette_cache.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 namespace lilia::view
 {
@@ -17,7 +17,7 @@ namespace lilia::view
 
     static Entity makeHL(std::string_view texName, bool scaleToSquare)
     {
-      Entity e(TextureTable::getInstance().get(std::string{texName}));
+      Entity e(ResourceTable::getInstance().getTexture(std::string{texName}));
 
       if (scaleToSquare)
       {
diff --git a/src/lilia/view/ui/render/player_info_resolver.cpp b/src/lilia/view/ui/render/player_info_resolver.cpp
index 4fcbdba..adc2418 100644
--- a/src/lilia/view/ui/render/player_info_resolver.cpp
+++ b/src/lilia/view/ui/render/player_info_resolver.cpp
@@ -79,22 +79,22 @@ namespace lilia::view
     return std::string(ui::icons::EXTERNAL);
   }
 
-  PlayerInfo makePlayerInfo(const lilia::config::SideConfig &side, core::Color /*color*/)
+  model::analysis::PlayerInfo makePlayerInfo(const lilia::config::SideConfig &side, core::Color /*color*/)
   {
-    PlayerInfo info{};
+    model::analysis::PlayerInfo info{};
     info.elo = "";
 
     if (side.kind == lilia::config::SideKind::Human || !side.bot.has_value() ||
         side.bot->engine.engineId.empty())
     {
-      info.name = "Human";
-      info.iconPath = std::string(ui::icons::DEFAULT_FALLBACK);
+      info.name = "Challenger";
+      info.icon_name = std::string(ui::icons::DEFAULT_FALLBACK);
       return info;
     }
 
     const auto &ref = side.bot->engine;
     info.name = ref.displayName.empty() ? ref.engineId : ref.displayName;
-    info.iconPath = iconForEngine(ref);
+    info.icon_name = iconForEngine(ref);
     return info;
   }
 } // namespace lilia::view
diff --git a/src/lilia/view/ui/render/texture_table.cpp b/src/lilia/view/ui/render/resource_table.cpp
similarity index 89%
rename from src/lilia/view/ui/render/texture_table.cpp
rename to src/lilia/view/ui/render/resource_table.cpp
index 9eac3e5..f56c113 100755
--- a/src/lilia/view/ui/render/texture_table.cpp
+++ b/src/lilia/view/ui/render/resource_table.cpp
@@ -1,4 +1,4 @@
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 #include <SFML/Graphics.hpp>
 #include <stdexcept>
@@ -9,13 +9,13 @@
 namespace lilia::view
 {
 
-  TextureTable &TextureTable::getInstance()
+  ResourceTable &ResourceTable::getInstance()
   {
-    static TextureTable instance;
+    static ResourceTable instance;
     return instance;
   }
 
-  TextureTable::TextureTable()
+  ResourceTable::ResourceTable()
   {
     // Initial build
     preLoad();
@@ -24,7 +24,7 @@ namespace lilia::view
     m_paletteListenerId = PaletteCache::get().addListener([this]
                                                           { reloadForPalette(); });
   }
-  TextureTable::~TextureTable()
+  ResourceTable::~ResourceTable()
   {
     if (m_paletteListenerId != 0)
     {
@@ -32,12 +32,12 @@ namespace lilia::view
     }
   }
 
-  void TextureTable::reloadForPalette()
+  void ResourceTable::reloadForPalette()
   {
     preLoad();
   }
 
-  void TextureTable::load(std::string_view name, const sf::Color &color, sf::Vector2u size)
+  void ResourceTable::load(std::string_view name, const sf::Color &color, sf::Vector2u size)
   {
     sf::Texture &texture = m_textures[std::string{name}];
     sf::Image image;
@@ -45,7 +45,7 @@ namespace lilia::view
     texture.loadFromImage(image);
   }
 
-  [[nodiscard]] const sf::Texture &TextureTable::get(const std::string &filename)
+  [[nodiscard]] const sf::Texture &ResourceTable::getTexture(const std::string &filename)
   {
     auto it = m_textures.find(filename);
     if (it != m_textures.end())
@@ -60,6 +60,48 @@ namespace lilia::view
     return m_textures[filename];
   }
 
+  [[nodiscard]] const sf::Texture &ResourceTable::getAssetTexture(const std::string &filename)
+  {
+    auto it = m_textures.find(filename);
+    if (it != m_textures.end())
+      return it->second;
+
+    std::string_view file_dirs[] = {constant::path::ICONS_DIR, constant::path::PIECES_DIR};
+    sf::Texture texture;
+
+    for (auto dir : file_dirs)
+    {
+      if (texture.loadFromFile(std::string{dir} + "/" + filename))
+      {
+        m_textures[filename] = std::move(texture);
+        return m_textures[filename];
+      }
+    }
+    throw std::runtime_error("Error when loading asset: " + filename);
+    return {};
+  }
+
+  [[nodiscard]] const sf::Image &ResourceTable::getImage(const std::string &filename)
+  {
+    auto it = m_images.find(filename);
+    if (it != m_images.end())
+      return it->second;
+
+    std::string_view file_dirs[] = {constant::path::ICONS_DIR, constant::path::PIECES_DIR};
+    sf::Image img;
+
+    for (auto dir : file_dirs)
+    {
+      if (img.loadFromFile(std::string{dir} + "/" + filename))
+      {
+        m_images[filename] = std::move(img);
+        return m_images[filename];
+      }
+    }
+    throw std::runtime_error("Error when loading image: " + filename);
+    return {};
+  }
+
   namespace
   {
 
@@ -430,7 +472,7 @@ void main()
 
   } // namespace
 
-  void TextureTable::preLoad()
+  void ResourceTable::preLoad()
   {
     const auto &p = PaletteCache::get().palette();
 
diff --git a/src/lilia/view/ui/render/scene/board_node.cpp b/src/lilia/view/ui/render/scene/board_node.cpp
index f3f098a..9f63ded 100755
--- a/src/lilia/view/ui/render/scene/board_node.cpp
+++ b/src/lilia/view/ui/render/scene/board_node.cpp
@@ -66,7 +66,7 @@ namespace lilia::view
     static bool s_loaded = false;
     if (!s_loaded)
     {
-      s_loaded = s_font.loadFromFile(std::string{constant::path::FONT});
+      s_loaded = s_font.loadFromFile(std::string{constant::path::FONT_DIR});
       if (s_loaded)
       {
         // UPDATED: was setSmooth(false) -> caused pixelated glyph edges/outlines.
diff --git a/src/lilia/view/ui/render/scene/piece_manager.cpp b/src/lilia/view/ui/render/scene/piece_manager.cpp
index 1f5fb88..4a65152 100755
--- a/src/lilia/view/ui/render/scene/piece_manager.cpp
+++ b/src/lilia/view/ui/render/scene/piece_manager.cpp
@@ -6,7 +6,7 @@
 
 #include "lilia/view/animation/chess_animator.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/scene/piece_texture_util.hpp"
 
 namespace lilia::view
 {
@@ -117,15 +117,7 @@ namespace lilia::view
 
   void PieceManager::addPiece(core::PieceType type, core::Color color, core::Square pos)
   {
-    std::uint8_t numTypes = 6;
-    std::string filename = std::string{constant::path::PIECES_DIR} + std::string("/piece_") +
-                           std::to_string(static_cast<std::uint8_t>(type) +
-                                          numTypes * static_cast<std::uint8_t>(color)) +
-                           ".png";
-
-    const sf::Texture &texture = TextureTable::getInstance().get(filename);
-
-    Piece newpiece(color, type, texture);
+    Piece newpiece(color, type, ui::render::utils::getPieceTexture(type, color));
     newpiece.setScale(constant::PIECE_SCALE, constant::PIECE_SCALE);
     m_pieces[pos] = std::move(newpiece);
     m_pieces[pos].setPosition(createPiecePositon(pos));
@@ -370,13 +362,7 @@ namespace lilia::view
 
   static Piece makeGhost(core::PieceType type, core::Color color)
   {
-    constexpr std::uint8_t numTypes = 6;
-    std::string filename = std::string{constant::path::PIECES_DIR} + std::string("/piece_") +
-                           std::to_string(static_cast<std::uint8_t>(type) +
-                                          numTypes * static_cast<std::uint8_t>(color)) +
-                           ".png";
-    const sf::Texture &texture = TextureTable::getInstance().get(filename);
-    Piece p(color, type, texture);
+    Piece p(color, type, ui::render::utils::getPieceTexture(type, color));
     p.setScale(constant::PIECE_SCALE, constant::PIECE_SCALE);
     return p;
   }
@@ -495,12 +481,7 @@ namespace lilia::view
     // behavior (reload textures) but trigger via PaletteCache now.
     auto reload = [](Piece &p)
     {
-      std::uint8_t numTypes = 6;
-      std::string filename = std::string{constant::path::PIECES_DIR} + std::string("/piece_") +
-                             std::to_string(static_cast<std::uint8_t>(p.getType()) +
-                                            numTypes * static_cast<std::uint8_t>(p.getColor())) +
-                             ".png";
-      p.setTexture(TextureTable::getInstance().get(filename));
+      p.setTexture(ui::render::utils::getPieceTexture(p.getType(), p.getColor()));
       p.setScale(constant::PIECE_SCALE, constant::PIECE_SCALE);
     };
 
diff --git a/src/lilia/view/ui/render/scene/piece_texture_util.cpp b/src/lilia/view/ui/render/scene/piece_texture_util.cpp
new file mode 100644
index 0000000..f8dd129
--- /dev/null
+++ b/src/lilia/view/ui/render/scene/piece_texture_util.cpp
@@ -0,0 +1,11 @@
+#include "lilia/view/ui/render/scene/piece_texture_util.hpp"
+
+const sf::Texture &lilia::view::ui::render::utils::getPieceTexture(core::PieceType type, core::Color color)
+{
+  constexpr std::uint8_t numTypes = 6;
+  std::string filename = std::string("piece_") +
+                         std::to_string(static_cast<std::uint8_t>(type) +
+                                        numTypes * static_cast<std::uint8_t>(color)) +
+                         ".png";
+  return ResourceTable::getInstance().getAssetTexture(filename);
+}
diff --git a/src/lilia/view/ui/render/scene/promotion.cpp b/src/lilia/view/ui/render/scene/promotion.cpp
index 8d27599..51ac5c9 100755
--- a/src/lilia/view/ui/render/scene/promotion.cpp
+++ b/src/lilia/view/ui/render/scene/promotion.cpp
@@ -1,7 +1,7 @@
 #include "lilia/view/ui/render/scene/promotion.hpp"
 
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/scene/piece_texture_util.hpp"
 
 namespace lilia::view
 {
@@ -9,14 +9,7 @@ namespace lilia::view
   Promotion::Promotion(Entity::Position pos, core::PieceType type, core::Color color)
       : Entity(pos), m_type(type)
   {
-    std::uint8_t numTypes = 6;
-    std::string filename = std::string{constant::path::PIECES_DIR} + "/piece_" +
-                           std::to_string(static_cast<std::uint8_t>(type) +
-                                          numTypes * static_cast<std::uint8_t>(color)) +
-                           ".png";
-
-    const sf::Texture &texture = TextureTable::getInstance().get(filename);
-    setTexture(texture);
+    setTexture(ui::render::utils::getPieceTexture(type, color));
     setScale(constant::PIECE_SCALE, constant::PIECE_SCALE);
     setOriginToCenter();
   }
diff --git a/src/lilia/view/ui/screens/game_view.cpp b/src/lilia/view/ui/screens/game_view.cpp
index d0be375..d73afa7 100755
--- a/src/lilia/view/ui/screens/game_view.cpp
+++ b/src/lilia/view/ui/screens/game_view.cpp
@@ -4,7 +4,6 @@
 #include <algorithm>
 
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
 #include "lilia/view/ui/style/modals/modal.hpp"
 #include "lilia/view/ui/style/style.hpp"
 
@@ -40,10 +39,8 @@ namespace lilia::view
         m_cursor_manager(window),
         m_eval_bar(),
         m_move_list(),
-        // EXACTLY TWO players: one per color
         m_white_player(),
         m_black_player(),
-        // (Recommended) EXACTLY TWO clocks: one per color
         m_white_clock(),
         m_black_clock(),
         m_modal(),
@@ -55,20 +52,6 @@ namespace lilia::view
     m_white_player.setPlayerColor(core::Color::White);
     m_black_player.setPlayerColor(core::Color::Black);
 
-    // Safe defaults (avoid empty icon path lookups before controller sets real info)
-    PlayerInfo w{};
-    w.name = "White";
-    w.elo = "";
-    w.iconPath = std::string{constant::path::ICON_CHALLENGER};
-
-    PlayerInfo b{};
-    b.name = "Black";
-    b.elo = "";
-    b.iconPath = std::string{constant::path::ICON_CHALLENGER};
-
-    m_white_player.setInfo(w);
-    m_black_player.setInfo(b);
-
     // Fixed clock identity (never swapped)
     m_white_clock.setPlayerColor(core::Color::White);
     m_black_clock.setPlayerColor(core::Color::Black);
@@ -81,7 +64,7 @@ namespace lilia::view
     layout(m_window.getSize().x, m_window.getSize().y);
 
     // theme font for modals (same face as the rest of UI)
-    m_modal.loadFont(std::string{constant::path::FONT});
+    m_modal.loadFont(std::string{constant::path::FONT_DIR});
   }
 
   void GameView::init(const std::string &fen)
@@ -574,7 +557,7 @@ namespace lilia::view
 
   void GameView::endAnimation(core::Square sq) { m_chess_animator.end(sq); }
 
-  void GameView::setPlayers(const PlayerInfo &white, const PlayerInfo &black)
+  void GameView::setPlayersInfo(const model::analysis::PlayerInfo &white, const model::analysis::PlayerInfo &black)
   {
     m_white_player.setInfo(white);
     m_black_player.setInfo(black);
@@ -605,7 +588,7 @@ namespace lilia::view
     m_replay_header = std::move(header);
     if (m_replay_header)
     {
-      setPlayers(m_replay_header->white, m_replay_header->black);
+      setPlayersInfo(m_replay_header->white_info, m_replay_header->black_info);
       m_move_list.setReplayHeader(m_replay_header);
 
       setOutcomeBadges(m_replay_header->whiteOutcome, m_replay_header->blackOutcome);
diff --git a/src/lilia/view/ui/screens/start_screen.cpp b/src/lilia/view/ui/screens/start_screen.cpp
index 0d2357e..8b20a91 100755
--- a/src/lilia/view/ui/screens/start_screen.cpp
+++ b/src/lilia/view/ui/screens/start_screen.cpp
@@ -26,6 +26,7 @@
 #include "lilia/view/ui/style/modals/game_setup/game_setup_modal.hpp"
 #include "lilia/view/ui/style/modals/game_setup/game_setup_validation.hpp"
 #include "lilia/view/ui/style/modals/palette_picker_modal.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 namespace lilia::view
 {
@@ -114,8 +115,8 @@ namespace lilia::view
 
   StartScreen::StartScreen(sf::RenderWindow &window) : m_window(window)
   {
-    m_font.loadFromFile(std::string(constant::path::FONT));
-    m_logoTex.loadFromFile(std::string(constant::path::ICON_LILIA_START));
+    m_font.loadFromFile(std::string(constant::path::FONT_DIR));
+    m_logoTex = ResourceTable::getInstance().getAssetTexture(std::string(constant::asset_name::ICON_LILIA_START));
     m_logo.setTexture(m_logoTex);
   }
 
diff --git a/src/lilia/view/ui/style/game_setup/position_builder.cpp b/src/lilia/view/ui/style/game_setup/position_builder.cpp
index fa2759a..8e4e1c5 100644
--- a/src/lilia/view/ui/style/game_setup/position_builder.cpp
+++ b/src/lilia/view/ui/style/game_setup/position_builder.cpp
@@ -10,7 +10,7 @@
 
 #include "lilia/constants.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 
 #include "lilia/view/ui/style/style.hpp"
 #include "lilia/view/ui/style/theme.hpp"
@@ -974,7 +974,7 @@ namespace lilia::view
 
       const int colorIdx = white ? 0 : 1;
       const int idx = t + 6 * colorIdx;
-      return std::string{constant::path::PIECES_DIR} + "/piece_" + std::to_string(idx) + ".png";
+      return "piece_" + std::to_string(idx) + ".png";
     }
 
     static int pieceSlotFromChar(char p)
@@ -992,8 +992,8 @@ namespace lilia::view
       if (texReady)
         return;
 
-      texWhite = &TextureTable::getInstance().get(std::string{constant::tex::WHITE});
-      texBlack = &TextureTable::getInstance().get(std::string{constant::tex::BLACK});
+      texWhite = &ResourceTable::getInstance().getTexture(std::string{constant::tex::WHITE});
+      texBlack = &ResourceTable::getInstance().getTexture(std::string{constant::tex::BLACK});
 
       if (texWhite && texWhite->getSize().x > 0)
       {
@@ -1022,7 +1022,7 @@ namespace lilia::view
         if (fn.empty())
           return;
 
-        const sf::Texture &t = TextureTable::getInstance().get(fn);
+        const sf::Texture &t = ResourceTable::getInstance().getAssetTexture(fn);
         pieceTex[slot] = &t;
 
         sf::Sprite spr;
diff --git a/src/lilia/view/ui/views/board_view.cpp b/src/lilia/view/ui/views/board_view.cpp
index cd2b270..782ad81 100755
--- a/src/lilia/view/ui/views/board_view.cpp
+++ b/src/lilia/view/ui/views/board_view.cpp
@@ -7,7 +7,7 @@
 
 #include "lilia/view/ui/style/palette_cache.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 #include "lilia/view/ui/style/style.hpp"
 
 namespace lilia::view
@@ -45,7 +45,7 @@ namespace lilia::view
       static bool s_loaded = false;
       if (!s_loaded)
       {
-        s_loaded = s_font.loadFromFile(std::string{constant::path::FONT});
+        s_loaded = s_font.loadFromFile(std::string{constant::path::FONT_DIR});
         if (s_loaded)
           s_font.setSmooth(false);
       }
@@ -179,9 +179,9 @@ namespace lilia::view
   {
     const auto pal = PaletteCache::get().palette();
 
-    m_board.init(TextureTable::getInstance().get(std::string{constant::tex::WHITE}),
-                 TextureTable::getInstance().get(std::string{constant::tex::BLACK}),
-                 TextureTable::getInstance().get(std::string{constant::tex::TRANSPARENT}),
+    m_board.init(ResourceTable::getInstance().getTexture(std::string{constant::tex::WHITE}),
+                 ResourceTable::getInstance().getTexture(std::string{constant::tex::BLACK}),
+                 ResourceTable::getInstance().getTexture(std::string{constant::tex::TRANSPARENT}),
                  pal[ColorId::COL_BOARD_OUTLINE]);
 
     setPosition(getPosition());
diff --git a/src/lilia/view/ui/views/clock.cpp b/src/lilia/view/ui/views/clock.cpp
index 4f741d7..9e5f653 100755
--- a/src/lilia/view/ui/views/clock.cpp
+++ b/src/lilia/view/ui/views/clock.cpp
@@ -85,7 +85,7 @@ namespace lilia::view
     m_icon_hand.setOrigin(0.f, 0.5f);
     m_icon_hand.setRotation(-90.f); // up
 
-    m_font.loadFromFile(std::string{constant::path::FONT});
+    m_font.loadFromFile(std::string{constant::path::FONT_DIR});
     m_font.setSmooth(false);
 
     m_text.setFont(m_font);
diff --git a/src/lilia/view/ui/views/eval_bar.cpp b/src/lilia/view/ui/views/eval_bar.cpp
index f8d640e..68b793c 100755
--- a/src/lilia/view/ui/views/eval_bar.cpp
+++ b/src/lilia/view/ui/views/eval_bar.cpp
@@ -14,7 +14,7 @@
 #include "lilia/engine/config.hpp"
 #include "lilia/view/ui/style/palette_cache.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 #include "lilia/view/ui/style/style.hpp"
 
 namespace lilia::view
@@ -35,19 +35,19 @@ namespace lilia::view
 
   EvalBar::EvalBar() : EvalBar::Entity()
   {
-    setTexture(TextureTable::getInstance().get(std::string{constant::tex::TRANSPARENT}));
+    setTexture(ResourceTable::getInstance().getTexture(std::string{constant::tex::TRANSPARENT}));
     setScale(constant::EVAL_BAR_WIDTH, constant::EVAL_BAR_HEIGHT);
     setOriginToCenter();
 
-    m_black_background.setTexture(TextureTable::getInstance().get(std::string{constant::tex::EVAL_BLACK}));
-    m_white_fill_eval.setTexture(TextureTable::getInstance().get(std::string{constant::tex::EVAL_WHITE}));
+    m_black_background.setTexture(ResourceTable::getInstance().getTexture(std::string{constant::tex::EVAL_BLACK}));
+    m_white_fill_eval.setTexture(ResourceTable::getInstance().getTexture(std::string{constant::tex::EVAL_WHITE}));
 
     m_black_background.setScale(constant::EVAL_BAR_WIDTH, constant::EVAL_BAR_HEIGHT);
     m_white_fill_eval.setScale(constant::EVAL_BAR_WIDTH, constant::EVAL_BAR_HEIGHT);
     m_black_background.setOriginToCenter();
     m_white_fill_eval.setOriginToCenter();
 
-    m_font.loadFromFile(std::string{constant::path::FONT});
+    m_font.loadFromFile(std::string{constant::path::FONT_DIR});
     m_font.setSmooth(false);
 
     m_score_text.setFont(m_font);
diff --git a/src/lilia/view/ui/views/move_list_view.cpp b/src/lilia/view/ui/views/move_list_view.cpp
index 3357ebe..b053e71 100755
--- a/src/lilia/view/ui/views/move_list_view.cpp
+++ b/src/lilia/view/ui/views/move_list_view.cpp
@@ -279,7 +279,7 @@ namespace lilia::view
 
   MoveListView::MoveListView()
   {
-    m_font.loadFromFile(std::string{constant::path::FONT});
+    m_font.loadFromFile(std::string{constant::path::FONT_DIR});
     m_font.setSmooth(false);
   }
 
diff --git a/src/lilia/view/ui/views/player_info_view.cpp b/src/lilia/view/ui/views/player_info_view.cpp
index 1b27a3f..f31301c 100755
--- a/src/lilia/view/ui/views/player_info_view.cpp
+++ b/src/lilia/view/ui/views/player_info_view.cpp
@@ -5,7 +5,7 @@
 
 #include "lilia/view/ui/style/palette_cache.hpp"
 #include "lilia/view/ui/render/render_constants.hpp"
-#include "lilia/view/ui/render/texture_table.hpp"
+#include "lilia/view/ui/render/resource_table.hpp"
 #include "lilia/view/ui/style/style.hpp"
 
 #include <unordered_map>
@@ -139,7 +139,7 @@ namespace lilia::view
 
     m_captureBox.setOutlineThickness(0.f);
 
-    if (m_font.loadFromFile(std::string(constant::path::FONT)))
+    if (m_font.loadFromFile(std::string(constant::path::FONT_DIR)))
     {
       m_font.setSmooth(false);
 
@@ -164,12 +164,12 @@ namespace lilia::view
   Entity PlayerInfoView::makeCapturedEntity(core::PieceType type, core::Color color)
   {
     constexpr std::uint8_t kNumTypes = 6;
-    const std::string filename = std::string{constant::path::PIECES_DIR} + "/piece_" +
+    const std::string filename = "piece_" +
                                  std::to_string(static_cast<std::uint8_t>(type) +
                                                 kNumTypes * static_cast<std::uint8_t>(color)) +
                                  ".png";
 
-    const sf::Texture &tex = TextureTable::getInstance().get(filename);
+    const sf::Texture &tex = ResourceTable::getInstance().getAssetTexture(filename);
     Entity e(tex);
     e.setScale(1.f, 1.f);
     return e;
@@ -215,15 +215,14 @@ namespace lilia::view
     m_playerColor = color;
   }
 
-  void PlayerInfoView::setInfo(const PlayerInfo &info)
+  void PlayerInfoView::setInfo(const model::analysis::PlayerInfo &info)
   {
-    m_iconPath = info.iconPath;
-
-    const sf::Texture &tex = TextureTable::getInstance().get(m_iconPath);
+    m_icon_name = info.icon_name;
+    const sf::Texture &tex = ResourceTable::getInstance().getAssetTexture(m_icon_name);
     m_icon.setTexture(tex);
 
     // Crop away transparent padding (safe fallback inside helper)
-    const sf::IntRect tight = tightAlphaBoundsCached(m_iconPath, tex, 1);
+    const sf::IntRect tight = tightAlphaBoundsCached(m_icon_name, tex, 1);
     if (tight.width > 0 && tight.height > 0)
       m_icon.setTextureRect(tight);
 
